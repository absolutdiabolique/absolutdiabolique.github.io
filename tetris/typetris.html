<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TypeTris</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            transition: background-color 0.3s, color 0.3s;
        }

        body.theme-dark {
            background-color: rgb(18, 18, 20);
            color: rgb(180, 160, 180);
        }

        body.theme-purple {
            background-color: rgb(48, 8, 47);
            color: rgb(180, 120, 180);
        }

        body.theme-blue {
            background-color: rgb(8, 28, 48);
            color: rgb(120, 160, 180);
        }

        body.theme-red {
            background-color: rgb(48, 12, 12);
            color: rgb(200, 140, 140);
        }

        .container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        canvas {
            border: 2px solid currentColor;
            display: block;
            image-rendering: crisp-edges;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 250px;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border: 1px solid currentColor;
            border-radius: 4px;
            font-size: 14px;
        }

        .control-symbol {
            font-size: 20px;
            font-weight: bold;
            min-width: 30px;
        }

        .control-word {
            font-weight: bold;
            letter-spacing: 1px;
        }

        .control-word .letter {
            display: inline-block;
            transition: color 0.1s;
        }

        .control-word .letter.matched {
            color: inherit;
            opacity: 1;
            text-shadow: 0 0 8px currentColor;
        }

        .control-word .letter.unmatched {
            opacity: 0.3;
        }

        .next-word {
            font-size: 10px;
            opacity: 0.5;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        .input-display {
            padding: 12px;
            border: 2px solid currentColor;
            border-radius: 4px;
            font-size: 16px;
            letter-spacing: 2px;
            text-align: center;
            min-height: 40px;
            font-weight: bold;
        }

        .score-display {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .score-item {
            padding: 8px 12px;
            border: 1px solid currentColor;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px 50px;
            border: 3px solid currentColor;
            background-color: rgba(0, 0, 0, 0.9);
            font-size: 24px;
            text-align: center;
            display: none;
            flex-direction: column;
            gap: 15px;
        }

        .game-over.show {
            display: flex;
        }

        .button {
            padding: 10px 20px;
            border: 2px solid currentColor;
            background: transparent;
            color: currentColor;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .button:hover {
            background: currentColor;
            color: black;
        }

        .pause-menu {
            position: fixed;
            top: 30%;
            left: 50px;
            padding: 40px;
            border: 3px solid currentColor;
            background-color: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            gap: 15px;
            z-index: 100;
        }

        .pause-menu.show {
            display: flex;
        }

        .pause-menu .button {
            min-width: 150px;
        }

        .start-screen {
            position: fixed;
            top: 30%;
            left: 50px;
            padding: 50px;
            border: 3px solid currentColor;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            z-index: 100;
        }

        .start-screen.hidden {
            display: none;
        }

        .start-screen h1 {
            font-size: 36px;
            margin: 0;
        }

        .history-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 300px;
            max-width: 350px;
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border: 2px solid currentColor;
            font-weight: bold;
        }

        .sort-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .sort-button {
            padding: 4px 8px;
            border: 1px solid currentColor;
            background: transparent;
            color: currentColor;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .sort-button:hover, .sort-button.active {
            background: currentColor;
            color: black;
        }

        .history-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
            max-height: 500px;
            overflow-y: auto;
            padding: 5px;
            border: 1px solid currentColor;
        }

        .history-item {
            padding: 8px;
            border: 1px solid currentColor;
            font-size: 12px;
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .history-item-row {
            display: flex;
            justify-content: space-between;
        }

        .pause-button {
            padding: 8px 16px;
            border: 2px solid currentColor;
            background: transparent;
            color: currentColor;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .pause-button:hover {
            background: currentColor;
            color: black;
        }

        .help {
            font-size: 12px;
            opacity: 0.7;
            text-align: center;
            max-width: 250px;
        }

        .next-piece-preview {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px;
            border: 2px solid currentColor;
            background-color: rgba(0, 0, 0, 0.3);
            font-size: 10px;
            text-align: center;
        }

        .highlight {
            animation: pulse 0.3s ease;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
    </style>
</head>
<body class="theme-dark">
    <div class="container">
        <div class="game-area">
            <div style="position: relative;">
                <canvas id="tetris" width="300" height="600"></canvas>
                <div class="next-piece-preview">
                    <div style="margin-bottom: 5px;">NEXT</div>
                    <canvas id="nextPiece" width="60" height="60"></canvas>
                </div>
            </div>
            <div class="input-display" id="inputDisplay"></div>
            <div style="display: flex; gap: 10px;">
                <button class="pause-button" id="pauseButton" onclick="togglePause()">Pause</button>
                <button class="button" onclick="changeTheme()">Change Theme</button>
            </div>
            <div class="help">Type 4-letter words to control the pieces. Words change after each use!</div>
        </div>
        
        <div class="controls">
            <div class="score-display">
                <div class="score-item">
                    <span>Score:</span>
                    <span id="score">0</span>
                </div>
                <div class="score-item">
                    <span>Lines:</span>
                    <span id="lines">0</span>
                </div>
                <div class="score-item">
                    <span>Level:</span>
                    <span id="level">1</span>
                </div>
                <div class="score-item">
                    <span>WPM:</span>
                    <span id="cps">0.0</span>
                </div>
                <div class="score-item">
                    <span>High:</span>
                    <span id="highScore">0</span>
                </div>
                <div class="score-item">
                    <span>Seed:</span>
                    <input type="number" id="seedInput" value="0" style="width: 60px; background: transparent; border: 1px solid currentColor; color: currentColor; font-family: 'Courier New', monospace; padding: 2px 4px;">
                </div>
            </div>
            
            <div class="control-item" id="rotateLeft">
                <span class="control-symbol">↺</span>
                <div style="display: flex; flex-direction: column; align-items: flex-end;">
                    <span class="control-word" id="rotateLeftWord">SPIN</span>
                    <span class="next-word" id="rotateLeftNext">NEXT</span>
                </div>
            </div>
            <div class="control-item" id="rotateRight">
                <span class="control-symbol">↻</span>
                <div style="display: flex; flex-direction: column; align-items: flex-end;">
                    <span class="control-word" id="rotateRightWord">TURN</span>
                    <span class="next-word" id="rotateRightNext">NEXT</span>
                </div>
            </div>
            <div class="control-item" id="moveLeft">
                <span class="control-symbol">←</span>
                <div style="display: flex; flex-direction: column; align-items: flex-end;">
                    <span class="control-word" id="moveLeftWord">LEFT</span>
                    <span class="next-word" id="moveLeftNext">NEXT</span>
                </div>
            </div>
            <div class="control-item" id="moveRight">
                <span class="control-symbol">→</span>
                <div style="display: flex; flex-direction: column; align-items: flex-end;">
                    <span class="control-word" id="moveRightWord">RITE</span>
                    <span class="next-word" id="moveRightNext">NEXT</span>
                </div>
            </div>
            <div class="control-item" id="moveDown">
                <span class="control-symbol">↓</span>
                <div style="display: flex; flex-direction: column; align-items: flex-end;">
                    <span class="control-word" id="moveDownWord">DOWN</span>
                    <span class="next-word" id="moveDownNext">NEXT</span>
                </div>
            </div>
            <div class="control-item" id="hardDrop">
                <span class="control-symbol">↑</span>
                <div style="display: flex; flex-direction: column; align-items: flex-end;">
                    <span class="control-word" id="hardDropWord">DROP</span>
                    <span class="next-word" id="hardDropNext">NEXT</span>
                </div>
            </div>
            <div class="control-item" id="hold">
                <span class="control-symbol">⇄</span>
                <div style="display: flex; flex-direction: column; align-items: flex-end;">
                    <span class="control-word" id="holdWord">HOLD</span>
                    <span class="next-word" id="holdNext">NEXT</span>
                </div>
            </div>
        </div>

        <div class="history-panel">
            <div class="history-header">
                <span>Game History</span>
            </div>
            <div class="sort-buttons">
                <button class="sort-button active" onclick="sortHistory('time')">Time</button>
                <button class="sort-button" onclick="sortHistory('score')">Score</button>
                <button class="sort-button" onclick="sortHistory('lines')">Lines</button>
                <button class="sort-button" onclick="sortHistory('blocks')">Blocks</button>
            </div>
            <div class="history-list" id="historyList">
                <div style="opacity: 0.5; text-align: center; padding: 20px;">No games yet</div>
            </div>
        </div>
    </div>

    <div class="start-screen" id="startScreen">
        <h1>WORD TETRIS</h1>
        <p>Type 4-letter words to control the pieces</p>
        <button class="button" onclick="startGame()">Start Game</button>
    </div>

    <div class="pause-menu" id="pauseMenu">
        <button class="button" onclick="resumeGame()">Resume</button>
        <button class="button" onclick="restartGame()">Restart</button>
        <button class="button" onclick="endGame()">End Game</button>
    </div>

    <div class="game-over" id="gameOver">
        <div>GAME OVER</div>
        <div>Final Score: <span id="finalScore">0</span></div>
        <button class="button" onclick="resetGame()">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextPiece');
        const nextCtx = nextCanvas.getContext('2d');
        const BLOCK_SIZE = 30;
        const COLS = 10;
        const ROWS = 20;

        // Seeded random number generator
        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
            }
            
            next() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
            
            nextInt(max) {
                return Math.floor(this.next() * max);
            }
        }

        // Word list (loaded from external JSON)
        let allWords = [];
    
        // Load words from words.json (must be an array of 4-letter words like ["word","gith","ubco"])
        function loadWords() {
            fetch('words.json')
                .then(response => {
                    if (!response.ok) throw new Error('HTTP ' + response.status);
                    return response.json();
                })
                .then(data => {
                    if (!Array.isArray(data)) throw new Error('words.json must contain an array');
                    // Keep only 4-letter alphabetic words, uppercased
                    allWords = data
                        .filter(w => typeof w === 'string' && /^[A-Za-z]{4}$/.test(w))
                        .map(w => w.toUpperCase());
    
                    if (allWords.length === 0) throw new Error('No valid 4-letter words found in words.json');
    
                    initializeWords();
                    // Populate UI with initial words for each action
                    Object.keys(wordPools).forEach(action => updateWord(action));
                })
                .catch(err => {
                    console.error('Failed to load words.json:', err);
                    // Fallback to a small embedded list so the game still works
                    allWords = ['ABLE','SPIN','TURN','LEFT','RITE','DOWN','DROP','HOLD'];
                    initializeWords();
                    Object.keys(wordPools).forEach(action => updateWord(action));
                });
        }
    
        // Shuffle array helper (unchanged)
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }
    
        // Word pools for each action (unchanged)
        let wordPools = {
            rotateLeft: [],
            rotateRight: [],
            moveLeft: [],
            moveRight: [],
            moveDown: [],
            hardDrop: [],
            hold: []
        };
    
        // Initialize word pools from loaded list
        function initializeWords() {
            const shuffled = shuffleArray(allWords);
            const wordsPerAction = Math.floor(shuffled.length / 7) || 1; // ensure at least 1 if possible
    
            const actions = Object.keys(wordPools);
            actions.forEach((action, i) => {
                const start = i * wordsPerAction;
                const end = start + wordsPerAction;
                wordPools[action] = shuffled.slice(start, end);
                // If slice produced an empty pool (because allWords < 7), ensure there's at least one word
                if (wordPools[action].length === 0 && shuffled.length > 0) {
                    wordPools[action] = [shuffled[i % shuffled.length]];
                }
            });
        }
    
        function getRandomWord(pool, exclude) {
            if (!pool || pool.length === 0) return '----';
            let available = pool.filter(word => word !== exclude);
            if (available.length === 0) available = [...pool];
            if (available.length === 0) return '----';
            if (seededRandom) {
                return available[seededRandom.nextInt(available.length)];
            }
            return available[Math.floor(Math.random() * available.length)];
        }
    
        // Call loadWords() once when script runs so UI/pools are ready
        loadWords();

        // Game state
        let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        let score = 0;
        let lines = 0;
        let level = 1;
        let gameOver = false;
        let inputBuffer = '';
        let currentPiece = null;
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let currentTheme = 0;
        const themes = ['theme-dark', 'theme-purple', 'theme-blue', 'theme-red'];
        let clearingLines = [];
        let clearAnimationFrame = 0;
        let highScore = parseInt(localStorage.getItem('wordTetrisHighScore') || '0');
        let heldPiece = null;
        let canHold = true;
        let onGround = false;
        let groundTicks = 0;
        let charCount = 0;
        let gameStartTime = null;
        let transitionCells = []; // Array of {x, y, targetColor, startTime, duration}
        let isPaused = false;
        let isGameStarted = false;
        let blocksPlaced = 0;
        let gameHistory = JSON.parse(localStorage.getItem('wordTetrisHistory') || '[]');
        let currentSortBy = 'time';

        // Current words for each action
        let currentWords = {
            rotateLeft: 'SPIN',
            rotateRight: 'TURN',
            moveLeft: 'LEFT',
            moveRight: 'RITE',
            moveDown: 'DOWN',
            hardDrop: 'DROP',
            hold: 'HOLD'
        };

        // Next words for each action
        let nextWords = {
            rotateLeft: '',
            rotateRight: '',
            moveLeft: '',
            moveRight: '',
            moveDown: '',
            hardDrop: '',
            hold: ''
        };

        let seededRandom = null;
        let nextPieceType = null;
        let wordsTypedCount = 0;

        // Tetris Theme (Korobeiniki) - Note sequence
        // Notes are in scientific pitch notation
        const tetrisTheme = [
            // Main melody
            'E5', 'B4', 'C5', 'D5', 'C5', 'B4', 'A4', 'A4', 'C5', 'E5', 'D5', 'C5', 'B4',
            'B4', 'C5', 'D5', 'E5', 'C5', 'A4', 'A4', 'A4', 'B4', 'C5', 'D5', 'F5', 'A5',
            'G5', 'F5', 'E5', 'C5', 'E5', 'D5', 'C5', 'B4', 'B4', 'C5', 'D5', 'E5', 'C5',
            'A4', 'A4',
            // Repeat
            'E5', 'B4', 'C5', 'D5', 'C5', 'B4', 'A4', 'A4', 'C5', 'E5', 'D5', 'C5', 'B4',
            'B4', 'C5', 'D5', 'E5', 'C5', 'A4', 'A4', 'A4', 'B4', 'C5', 'D5', 'F5', 'A5',
            'G5', 'F5', 'E5', 'C5', 'E5', 'D5', 'C5', 'B4', 'B4', 'C5', 'D5', 'E5', 'C5',
            'A4', 'A4'
        ];

        // Note frequencies in Hz
        const noteFrequencies = {
            'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
            'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46, 'G5': 783.99, 'A5': 880.00, 'B5': 987.77,
            'C6': 1046.50
        };

        let audioContext = null;
        let currentNoteIndex = 0;
        
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        function playNextNote() {
            if (!audioContext) return;
            
            const note = tetrisTheme[currentNoteIndex];
            const frequency = noteFrequencies[note];
            
            // Create oscillator
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'square'; // Retro sound
            oscillator.frequency.value = frequency;
            
            // Volume envelope for a more pleasant sound
            const now = audioContext.currentTime;
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.15, now + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            
            oscillator.start(now);
            oscillator.stop(now + 0.15);
            
            // Move to next note, loop back if at end
            currentNoteIndex = (currentNoteIndex + 1) % tetrisTheme.length;
        }

        // Tetromino shapes
        const PIECES = {
            'I': [[1,1,1,1]],
            'O': [[1,1],[1,1]],
            'T': [[0,1,0],[1,1,1]],
            'S': [[0,1,1],[1,1,0]],
            'Z': [[1,1,0],[0,1,1]],
            'J': [[1,0,0],[1,1,1]],
            'L': [[0,0,1],[1,1,1]]
        };

        const COLORS = {
            'I': 'rgb(100, 180, 200)',
            'O': 'rgb(200, 180, 100)',
            'T': 'rgb(160, 100, 180)',
            'S': 'rgb(120, 180, 120)',
            'Z': 'rgb(200, 120, 120)',
            'J': 'rgb(100, 120, 180)',
            'L': 'rgb(200, 150, 100)'
        };

        class Piece {
            constructor(forcedType = null) {
                const types = Object.keys(PIECES);
                if (forcedType) {
                    this.type = forcedType;
                } else if (seededRandom) {
                    this.type = types[seededRandom.nextInt(types.length)];
                } else {
                    this.type = types[Math.floor(Math.random() * types.length)];
                }
                this.shape = PIECES[this.type];
                this.color = COLORS[this.type];
                this.x = Math.floor(COLS / 2) - Math.floor(this.shape[0].length / 2);
                this.y = 0;
                this.rotationCount = 0;
            }

            rotate(clockwise = true) {
                const newShape = [];
                if (clockwise) {
                    for (let i = 0; i < this.shape[0].length; i++) {
                        newShape[i] = [];
                        for (let j = this.shape.length - 1; j >= 0; j--) {
                            newShape[i].push(this.shape[j][i]);
                        }
                    }
                } else {
                    for (let i = this.shape[0].length - 1; i >= 0; i--) {
                        newShape[this.shape[0].length - 1 - i] = [];
                        for (let j = 0; j < this.shape.length; j++) {
                            newShape[this.shape[0].length - 1 - i].push(this.shape[j][i]);
                        }
                    }
                }
                
                const oldShape = this.shape;
                const oldX = this.x;
                this.shape = newShape;
                
                // Wall kick
                if (this.collides()) {
                    this.x = oldX - 1;
                    if (this.collides()) {
                        this.x = oldX + 1;
                        if (this.collides()) {
                            this.x = oldX;
                            this.shape = oldShape;
                            return false;
                        }
                    }
                }
                
                this.rotationCount++;
                return true;
            }

            move(dx, dy) {
                this.x += dx;
                this.y += dy;
                
                if (this.collides()) {
                    this.x -= dx;
                    this.y -= dy;
                    return false;
                }
                return true;
            }

            collides() {
                for (let y = 0; y < this.shape.length; y++) {
                    for (let x = 0; x < this.shape[y].length; x++) {
                        if (this.shape[y][x]) {
                            const newX = this.x + x;
                            const newY = this.y + y;
                            
                            if (newX < 0 || newX >= COLS || newY >= ROWS) {
                                return true;
                            }
                            
                            if (newY >= 0 && board[newY][newX]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            isOnGround() {
                for (let y = 0; y < this.shape.length; y++) {
                    for (let x = 0; x < this.shape[y].length; x++) {
                        if (this.shape[y][x]) {
                            const newX = this.x + x;
                            const newY = this.y + y + 1;
                            
                            if (newY >= ROWS) {
                                return true;
                            }
                            
                            if (newY >= 0 && board[newY][newX]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            getDropDistance() {
                let distance = 0;
                while (true) {
                    this.y++;
                    distance++;
                    if (this.collides()) {
                        this.y -= distance;
                        return distance - 1;
                    }
                }
            }
            lock() {
                for (let y = 0; y < this.shape.length; y++) {
                    for (let x = 0; x < this.shape[y].length; x++) {
                        if (this.shape[y][x]) {
                            const boardY = this.y + y;
                            const boardX = this.x + x;
                            if (boardY >= 0) {
                                // Write to board immediately
                                board[boardY][boardX] = this.color;

                                // Keep transition animation
                                transitionCells.push({
                                    x: boardX,
                                    y: boardY,
                                    targetColor: this.color,
                                    startTime: Date.now(),
                                    duration: 100
                                });
                            }
                        }
                    }
                }
            }
        }

        function holdPiece() {
            if (!canHold) return;
            
            if (heldPiece === null) {
                heldPiece = currentPiece.type;
                currentPiece = new Piece();
            } else {
                const temp = heldPiece;
                heldPiece = currentPiece.type;
                currentPiece = new Piece();
                currentPiece.type = temp;
                currentPiece.shape = PIECES[temp];
                currentPiece.color = COLORS[temp];
            }
            
            canHold = false;
            onGround = false;
            groundTicks = 0;
        }

        function saveGameToHistory() {
            const game = {
                timestamp: Date.now(),
                date: new Date().toLocaleString(),
                score: score,
                lines: lines,
                blocks: blocksPlaced,
                cps: document.getElementById('cps').textContent
            };
            
            gameHistory.unshift(game);
            
            // Keep only last 50 games
            if (gameHistory.length > 50) {
                gameHistory = gameHistory.slice(0, 50);
            }
            
            localStorage.setItem('wordTetrisHistory', JSON.stringify(gameHistory));
            renderHistory();
        }

        function renderHistory() {
            const historyList = document.getElementById('historyList');
            
            if (gameHistory.length === 0) {
                historyList.innerHTML = '<div style="opacity: 0.5; text-align: center; padding: 20px;">No games yet</div>';
                return;
            }
            
            historyList.innerHTML = gameHistory.map((game, index) => `
                <div class="history-item">
                    <div class="history-item-row">
                        <strong>#${index + 1}</strong>
                        <span>${game.date}</span>
                    </div>
                    <div class="history-item-row">
                        <span>Score: ${game.score}</span>
                        <span>Lines: ${game.lines}</span>
                    </div>
                    <div class="history-item-row">
                        <span>Blocks: ${game.blocks}</span>
                        <span>CPS: ${game.cps}</span>
                    </div>
                </div>
            `).join('');
        }

        function sortHistory(sortBy) {
            currentSortBy = sortBy;
            
            // Update active button
            document.querySelectorAll('.sort-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Sort the history
            const sorted = [...gameHistory];
            switch(sortBy) {
                case 'time':
                    sorted.sort((a, b) => b.timestamp - a.timestamp);
                    break;
                case 'score':
                    sorted.sort((a, b) => b.score - a.score);
                    break;
                case 'lines':
                    sorted.sort((a, b) => b.lines - a.lines);
                    break;
                case 'blocks':
                    sorted.sort((a, b) => b.blocks - a.blocks);
                    break;
            }
            
            const historyList = document.getElementById('historyList');
            historyList.innerHTML = sorted.map((game, index) => `
                <div class="history-item">
                    <div class="history-item-row">
                        <strong>#${index + 1}</strong>
                        <span>${game.date}</span>
                    </div>
                    <div class="history-item-row">
                        <span>Score: ${game.score}</span>
                        <span>Lines: ${game.lines}</span>
                    </div>
                    <div class="history-item-row">
                        <span>Blocks: ${game.blocks}</span>
                        <span>CPS: ${game.cps}</span>
                    </div>
                </div>
            `).join('');
        }

        function togglePause() {
            if (!isGameStarted || gameOver) return;
            
            isPaused = !isPaused;
            
            if (isPaused) {
                document.getElementById('pauseMenu').classList.add('show');
            } else {
                document.getElementById('pauseMenu').classList.remove('show');
            }
        }

        function resumeGame() {
            isPaused = false;
            document.getElementById('pauseMenu').classList.remove('show');
            lastTime = performance.now();
            requestAnimationFrame(update);
        }

        function restartGame() {
            // Save current game if it has progress
            if (blocksPlaced > 0) {
                saveGameToHistory();
            }
            
            isPaused = false;
            document.getElementById('pauseMenu').classList.remove('show');
            resetGame();
        }

        function endGame() {
            // Save current game if it has progress
            if (blocksPlaced > 0) {
                saveGameToHistory();
            }
            
            isPaused = false;
            isGameStarted = false;
            gameOver = false;
            document.getElementById('pauseMenu').classList.remove('show');
            document.getElementById('startScreen').classList.remove('hidden');
            
            // Clear board
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            currentPiece = null;
            draw();
        }

        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            isGameStarted = true;
            resetGame();
        }

        function getRandomWord(pool, exclude) {
            const available = pool.filter(word => word !== exclude);
            if (seededRandom) {
                return available[seededRandom.nextInt(available.length)];
            }
            return available[Math.floor(Math.random() * available.length)];
        }

        function updateWord(action) {
            const pool = wordPools[action];
            
            // Move next word to current
            if (nextWords[action]) {
                currentWords[action] = nextWords[action];
            } else {
                currentWords[action] = getRandomWord(pool, currentWords[action]);
            }
            
            // Generate new next word
            nextWords[action] = getRandomWord(pool, currentWords[action]);
            
            // Update current word display
            const wordElement = document.getElementById(action + 'Word');
            wordElement.innerHTML = currentWords[action].split('').map(letter => 
                `<span class="letter unmatched">${letter}</span>`
            ).join('');
            
            // Update next word display
            document.getElementById(action + 'Next').textContent = nextWords[action];
            
            // Highlight the control
            document.getElementById(action).classList.add('highlight');
            setTimeout(() => {
                document.getElementById(action).classList.remove('highlight');
            }, 300);
        }

        function updateLetterHighlights() {
            const buffer = inputBuffer.slice(-4).toUpperCase();
            
            for (const action in currentWords) {
                const word = currentWords[action];
                const wordElement = document.getElementById(action + 'Word');
                const letters = wordElement.querySelectorAll('.letter');
                
                for (let i = 0; i < letters.length; i++) {
                    if (i < buffer.length && buffer[i] === word[i]) {
                        letters[i].classList.remove('unmatched');
                        letters[i].classList.add('matched');
                    } else {
                        letters[i].classList.remove('matched');
                        letters[i].classList.add('unmatched');
                    }
                }
            }
        }

        function checkInput() {
            if (inputBuffer.length < 4) return;
            
            const last4 = inputBuffer.slice(-4).toUpperCase();
            let actionTaken = false;
            let bonusPoints = 0;
            
            if (last4 === currentWords.rotateLeft) {
                const rotated = currentPiece.rotate(false);
                if (rotated) {
                    updateWord('rotateLeft');
                    actionTaken = true;
                    wordsTypedCount++;
                    // Check for T-spin potential
                    if (currentPiece.type === 'T' && currentPiece.isOnGround()) {
                        bonusPoints = 100 * level;
                    }
                }
            } else if (last4 === currentWords.rotateRight) {
                const rotated = currentPiece.rotate(true);
                if (rotated) {
                    updateWord('rotateRight');
                    actionTaken = true;
                    wordsTypedCount++;
                    // Check for T-spin potential
                    if (currentPiece.type === 'T' && currentPiece.isOnGround()) {
                        bonusPoints = 100 * level;
                    }
                }
            } else if (last4 === currentWords.moveLeft) {
                if (currentPiece.move(-1, 0)) {
                    updateWord('moveLeft');
                    actionTaken = true;
                    wordsTypedCount++;
                }
            } else if (last4 === currentWords.moveRight) {
                if (currentPiece.move(1, 0)) {
                    updateWord('moveRight');
                    actionTaken = true;
                    wordsTypedCount++;
                }
            } else if (last4 === currentWords.moveDown) {
                if (currentPiece.move(0, 1)) {
                    updateWord('moveDown');
                    actionTaken = true;
                    wordsTypedCount++;
                    score += 1;
                }
            } else if (last4 === currentWords.hardDrop) {
                const dropDistance = currentPiece.getDropDistance();
                while (currentPiece.move(0, 1)) {}
                bonusPoints = dropDistance * 2 * level;
                lockPiece();
                updateWord('hardDrop');
                actionTaken = true;
                wordsTypedCount++;
            } else if (last4 === currentWords.hold) {
                holdPiece();
                updateWord('hold');
                actionTaken = true;
                wordsTypedCount++;
            }
            
            if (actionTaken) {
                // Reset ground counter if piece moved off ground
                if (!currentPiece.isOnGround()) {
                    onGround = false;
                    groundTicks = 0;
                }
                
                // Add bonus points
                if (bonusPoints > 0) {
                    score += bonusPoints;
                    document.getElementById('score').textContent = score;
                }
            }
        }

        function lockPiece() {
            currentPiece.lock();
            blocksPlaced++;
            clearLines();
            
            // Use the next piece type if available
            if (nextPieceType) {
                currentPiece = new Piece(nextPieceType);
            } else {
                currentPiece = new Piece();
            }
            
            // Generate next piece type
            const types = Object.keys(PIECES);
            if (seededRandom) {
                nextPieceType = types[seededRandom.nextInt(types.length)];
            } else {
                nextPieceType = types[Math.floor(Math.random() * types.length)];
            }
            
            drawNextPiece();
            
            canHold = true;
            onGround = false;
            groundTicks = 0;
            
            if (currentPiece.collides()) {
                gameOver = true;
                const gameTime = (Date.now() - gameStartTime) / 1000;
                const wpm = (wordsTypedCount / gameTime * 60).toFixed(1);
                document.getElementById('cps').textContent = wpm;
                
                // Save game to history
                saveGameToHistory();
                
                document.getElementById('gameOver').classList.add('show');
                document.getElementById('finalScore').textContent = score;
            }
        }

        function clearLines() {
            const linesToClear = [];
            
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    linesToClear.push(y);
                }
            }
            
            if (linesToClear.length > 0) {
                clearingLines = linesToClear;
                clearAnimationFrame = 0;
                animateLineClear();
            }
        }

        function animateLineClear() {
            if (clearAnimationFrame < 10) {
                clearAnimationFrame++;
                setTimeout(() => {
                    draw();
                    animateLineClear();
                }, 50);
            } else {
                // Actually remove the lines
                clearingLines.sort((a, b) => a - b);
                for (const y of clearingLines) {
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(0));
                }
                
                const linesCleared = clearingLines.length;
                lines += linesCleared;
                score += [0, 100, 300, 500, 800][linesCleared] * level;
                level = Math.floor(lines / 10) + 1;
                dropInterval = Math.max(100, 1000 - (level - 1) * 100);
                
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('wordTetrisHighScore', highScore.toString());
                    document.getElementById('highScore').textContent = highScore;
                }
                
                document.getElementById('score').textContent = score;
                document.getElementById('lines').textContent = lines;
                document.getElementById('level').textContent = level;
                
                clearingLines = [];
                clearAnimationFrame = 0;
            }
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = getComputedStyle(document.body).backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const now = Date.now();
            
            // Process transition cells and update board
            transitionCells = transitionCells.filter(cell => {
                const elapsed = now - cell.startTime;
                if (elapsed >= cell.duration) {
                    board[cell.y][cell.x] = cell.targetColor;
                    return false;
                }
                return true;
            });
            
            // Draw gridlines
            ctx.strokeStyle = getComputedStyle(document.body).color;
            ctx.globalAlpha = 0.1;
            ctx.lineWidth = 1;
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK_SIZE, 0);
                ctx.lineTo(x * BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK_SIZE);
                ctx.lineTo(canvas.width, y * BLOCK_SIZE);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            
            // Draw board with retro scanline effect
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    let cellColor = board[y][x];
                    let isTransitioning = false;
                    let transitionProgress = 1;
                    
                    // Check if this cell is transitioning
                    const transition = transitionCells.find(t => t.x === x && t.y === y);
                    if (transition) {
                        const elapsed = now - transition.startTime;
                        transitionProgress = elapsed / transition.duration;
                        cellColor = transition.targetColor;
                        isTransitioning = true;
                    }
                    
                    if (cellColor) {
                        // Check if this line is being cleared
                        let alpha = 1;
                        if (clearingLines.includes(y)) {
                            alpha = Math.abs(Math.sin(clearAnimationFrame * 0.8)) * 0.8;
                        }
                        
                        // Apply transition effect - start at half opacity with scanlines
                        if (isTransitioning) {
                            alpha *= (0.5 + transitionProgress * 0.5);
                        }
                        
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = cellColor;
                        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                        
                        // Retro scanline effect
                        ctx.globalAlpha = alpha * 0.15;
                        ctx.fillStyle = 'white';
                        for (let scan = 0; scan < BLOCK_SIZE; scan += 2) {
                            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE + scan, BLOCK_SIZE - 1, 1);
                        }
                        ctx.globalAlpha = 1;
                    }
                }
            }
            
            // Draw current piece
            if (currentPiece && clearingLines.length === 0) {
                ctx.fillStyle = currentPiece.color;
                for (let y = 0; y < currentPiece.shape.length; y++) {
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x]) {
                            ctx.fillRect(
                                (currentPiece.x + x) * BLOCK_SIZE,
                                (currentPiece.y + y) * BLOCK_SIZE,
                                BLOCK_SIZE - 1,
                                BLOCK_SIZE - 1
                            );
                            
                            // Retro scanline effect
                            ctx.globalAlpha = 0.15;
                            ctx.fillStyle = 'white';
                            for (let scan = 0; scan < BLOCK_SIZE; scan += 2) {
                                ctx.fillRect(
                                    (currentPiece.x + x) * BLOCK_SIZE,
                                    (currentPiece.y + y) * BLOCK_SIZE + scan,
                                    BLOCK_SIZE - 1,
                                    1
                                );
                            }
                            ctx.globalAlpha = 1;
                            ctx.fillStyle = currentPiece.color;
                        }
                    }
                }
            }
            
            // Draw held piece in top-left corner
            if (heldPiece) {
                const heldShape = PIECES[heldPiece];
                const heldColor = COLORS[heldPiece];
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = heldColor;
                for (let y = 0; y < heldShape.length; y++) {
                    for (let x = 0; x < heldShape[y].length; x++) {
                        if (heldShape[y][x]) {
                            ctx.fillRect(
                                x * 15 + 10,
                                y * 15 + 10,
                                14,
                                14
                            );
                        }
                    }
                }
                ctx.globalAlpha = 1;
            }
        }

        function update(time = 0) {
            if (gameOver || !isGameStarted) return;
            
            if (isPaused) return;
            
            const deltaTime = time - lastTime;
            lastTime = time;
            
            // Update WPM display
            if (gameStartTime) {
                const gameTime = (Date.now() - gameStartTime) / 1000;
                const wpm = gameTime > 0 ? (wordsTypedCount / gameTime * 60).toFixed(1) : '0.0';
                document.getElementById('cps').textContent = wpm;
            }
            
            // Don't update game logic during line clear animation
            if (clearingLines.length === 0) {
                dropCounter += deltaTime;
                
                // Check if piece is on ground
                if (currentPiece.isOnGround()) {
                    if (!onGround) {
                        onGround = true;
                        groundTicks = 0;
                    }
                    groundTicks += deltaTime;
                    
                    // Lock after ~0.5 seconds on ground
                    if (groundTicks > 500) {
                        lockPiece();
                        dropCounter = 0;
                    }
                } else {
                    onGround = false;
                    groundTicks = 0;
                }
                
                if (dropCounter > dropInterval && !onGround) {
                    if (!currentPiece.move(0, 1)) {
                        // Just touched ground, start counter
                        onGround = true;
                        groundTicks = 0;
                    }
                    dropCounter = 0;
                }
            }
            
            draw();
            requestAnimationFrame(update);
        }

        function drawNextPiece() {
            if (!nextPieceType) return;
            
            // Clear next piece canvas
            nextCtx.fillStyle = getComputedStyle(document.body).backgroundColor;
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            
            const shape = PIECES[nextPieceType];
            const color = COLORS[nextPieceType];
            const blockSize = 12;
            
            // Center the piece in the preview
            const offsetX = (nextCanvas.width - shape[0].length * blockSize) / 2;
            const offsetY = (nextCanvas.height - shape.length * blockSize) / 2;
            
            nextCtx.fillStyle = color;
            nextCtx.globalAlpha = 0.8;
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        nextCtx.fillRect(
                            offsetX + x * blockSize,
                            offsetY + y * blockSize,
                            blockSize - 1,
                            blockSize - 1
                        );
                    }
                }
            }
            nextCtx.globalAlpha = 1;
        }

        async function resetGame() {
            // Get seed from input
            const seed = parseInt(document.getElementById('seedInput').value) || 0;
            seededRandom = new SeededRandom(seed);
            
            // Reset music to beginning
            currentNoteIndex = 0;
            
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            score = 0;
            lines = 0;
            level = 1;
            gameOver = false;
            inputBuffer = '';
            dropCounter = 0;
            dropInterval = 1000;
            clearingLines = [];
            clearAnimationFrame = 0;
            heldPiece = null;
            canHold = true;
            onGround = false;
            groundTicks = 0;
            charCount = 0;
            wordsTypedCount = 0;
            gameStartTime = Date.now();
            transitionCells = [];
            blocksPlaced = 0;
            isPaused = false;
            
            // Generate first piece
            currentPiece = new Piece();
            
            // Generate next piece type
            const types = Object.keys(PIECES);
            nextPieceType = types[seededRandom.nextInt(types.length)];
            drawNextPiece();
            
            document.getElementById('score').textContent = score;
            document.getElementById('lines').textContent = lines;
            document.getElementById('level').textContent = level;
            document.getElementById('highScore').textContent = highScore;
            document.getElementById('cps').textContent = '0.0';
            document.getElementById('gameOver').classList.remove('show');
            document.getElementById('inputDisplay').textContent = '';
            
            // Initialize new word pools
            initializeWords();
            
            // Initialize all control words with letter spans and next words
            for (const action in currentWords) {
                const pool = wordPools[action];
                currentWords[action] = getRandomWord(pool, '');
                nextWords[action] = getRandomWord(pool, currentWords[action]);
                
                const wordElement = document.getElementById(action + 'Word');
                wordElement.innerHTML = currentWords[action].split('').map(letter => 
                    `<span class="letter unmatched">${letter}</span>`
                ).join('');
                
                document.getElementById(action + 'Next').textContent = nextWords[action];
            }
            
            lastTime = performance.now();
            update();
        }

        function changeTheme() {
            // Invert the current theme by cycling through themes
            document.body.classList.remove(themes[currentTheme]);
            currentTheme = (currentTheme + 1) % themes.length;
            document.body.classList.add(themes[currentTheme]);
        }

        // Input handling
        document.addEventListener('keydown', (e) => {
            if (!isGameStarted || isPaused || gameOver) return;
            
            if (e.key.length === 1 && e.key.match(/[a-zA-Z]/)) {
                // Initialize audio on first keypress
                if (!audioContext) {
                    initAudio();
                }
                
                // Play the next note of the Tetris theme
                playNextNote();
                
                // Start game timer on first keypress
                if (!gameStartTime) {
                    gameStartTime = Date.now();
                }
                
                charCount++;
                inputBuffer += e.key.toUpperCase();
                
                // Keep only last 10 characters for display
                if (inputBuffer.length > 10) {
                    inputBuffer = inputBuffer.slice(-10);
                }
                
                document.getElementById('inputDisplay').textContent = inputBuffer;
                updateLetterHighlights();
                checkInput();
            }
        });

        // Initialize game
        (async function init() {
            document.getElementById('highScore').textContent = highScore;
            
            // Initialize word pools
            initializeWords();
            
            // Initialize all control words with letter spans
            for (const action in currentWords) {
                const word = currentWords[action];
                const wordElement = document.getElementById(action + 'Word');
                wordElement.innerHTML = word.split('').map(letter => 
                    `<span class="letter unmatched">${letter}</span>`
                ).join('');
            }
            
            // Render game history
            renderHistory();
            
            // Don't create piece or start update loop until game starts
        })();
    </script>
</body>
</html>
