<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TypeTris</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            transition: background-color 0.3s, color 0.3s;
        }

        body.theme-dark {
            background-color: rgb(18, 18, 20);
            color: rgb(180, 160, 180);
        }

        body.theme-purple {
            background-color: rgb(48, 8, 47);
            color: rgb(180, 120, 180);
        }

        body.theme-blue {
            background-color: rgb(8, 28, 48);
            color: rgb(120, 160, 180);
        }

        body.theme-red {
            background-color: rgb(48, 12, 12);
            color: rgb(200, 140, 140);
        }

        .container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        canvas {
            border: 2px solid currentColor;
            display: block;
            image-rendering: crisp-edges;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 250px;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border: 1px solid currentColor;
            border-radius: 4px;
            font-size: 14px;
        }

        .control-symbol {
            font-size: 20px;
            font-weight: bold;
            min-width: 30px;
        }

        .control-word {
            font-weight: bold;
            letter-spacing: 1px;
        }

        .control-word .letter {
            display: inline-block;
            transition: color 0.1s;
        }

        .control-word .letter.matched {
            color: inherit;
            opacity: 1;
            text-shadow: 0 0 8px currentColor;
        }

        .control-word .letter.unmatched {
            opacity: 0.3;
        }

        .input-display {
            padding: 12px;
            border: 2px solid currentColor;
            border-radius: 4px;
            font-size: 16px;
            letter-spacing: 2px;
            text-align: center;
            min-height: 40px;
            font-weight: bold;
        }

        .score-display {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .score-item {
            padding: 8px 12px;
            border: 1px solid currentColor;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px 50px;
            border: 3px solid currentColor;
            background-color: rgba(0, 0, 0, 0.9);
            font-size: 24px;
            text-align: center;
            display: none;
            flex-direction: column;
            gap: 15px;
        }

        .game-over.show {
            display: flex;
        }

        .button {
            padding: 10px 20px;
            border: 2px solid currentColor;
            background: transparent;
            color: currentColor;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .button:hover {
            background: currentColor;
            color: black;
        }

        .pause-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 40px;
            border: 3px solid currentColor;
            background-color: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            gap: 15px;
            z-index: 100;
        }

        .pause-menu.show {
            display: flex;
        }

        .pause-menu .button {
            min-width: 150px;
        }

        .start-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 50px;
            border: 3px solid currentColor;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            z-index: 100;
        }

        .start-screen.hidden {
            display: none;
        }

        .start-screen h1 {
            font-size: 36px;
            margin: 0;
        }

        .history-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 300px;
            max-width: 350px;
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border: 2px solid currentColor;
            font-weight: bold;
        }

        .sort-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .sort-button {
            padding: 4px 8px;
            border: 1px solid currentColor;
            background: transparent;
            color: currentColor;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .sort-button:hover, .sort-button.active {
            background: currentColor;
            color: black;
        }

        .history-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
            max-height: 500px;
            overflow-y: auto;
            padding: 5px;
            border: 1px solid currentColor;
        }

        .history-item {
            padding: 8px;
            border: 1px solid currentColor;
            font-size: 12px;
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .history-item-row {
            display: flex;
            justify-content: space-between;
        }

        .pause-button {
            padding: 8px 16px;
            border: 2px solid currentColor;
            background: transparent;
            color: currentColor;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .pause-button:hover {
            background: currentColor;
            color: black;
        }

        .help {
            font-size: 12px;
            opacity: 0.7;
            text-align: center;
            max-width: 250px;
        }

        .highlight {
            animation: pulse 0.3s ease;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
    </style>
</head>
<body class="theme-dark">
    <div class="container">
        <div class="game-area">
            <canvas id="tetris" width="300" height="600"></canvas>
            <div class="input-display" id="inputDisplay"></div>
            <div style="display: flex; gap: 10px;">
                <button class="pause-button" id="pauseButton" onclick="togglePause()">Pause</button>
                <button class="button" onclick="changeTheme()">Change Theme</button>
            </div>
            <div class="help">Type 4-letter words to control the pieces. Words change after each use!</div>
        </div>
        
        <div class="controls">
            <div class="score-display">
                <div class="score-item">
                    <span>Score:</span>
                    <span id="score">0</span>
                </div>
                <div class="score-item">
                    <span>Lines:</span>
                    <span id="lines">0</span>
                </div>
                <div class="score-item">
                    <span>Level:</span>
                    <span id="level">1</span>
                </div>
                <div class="score-item">
                    <span>CPS:</span>
                    <span id="cps">0.0</span>
                </div>
                <div class="score-item">
                    <span>High:</span>
                    <span id="highScore">0</span>
                </div>
            </div>
            
            <div class="control-item" id="rotateLeft">
                <span class="control-symbol">↺</span>
                <span class="control-word" id="rotateLeftWord">SPIN</span>
            </div>
            <div class="control-item" id="rotateRight">
                <span class="control-symbol">↻</span>
                <span class="control-word" id="rotateRightWord">TURN</span>
            </div>
            <div class="control-item" id="moveLeft">
                <span class="control-symbol">←</span>
                <span class="control-word" id="moveLeftWord">LEFT</span>
            </div>
            <div class="control-item" id="moveRight">
                <span class="control-symbol">→</span>
                <span class="control-word" id="moveRightWord">RITE</span>
            </div>
            <div class="control-item" id="moveDown">
                <span class="control-symbol">↓</span>
                <span class="control-word" id="moveDownWord">DOWN</span>
            </div>
            <div class="control-item" id="hardDrop">
                <span class="control-symbol">↑</span>
                <span class="control-word" id="hardDropWord">DROP</span>
            </div>
            <div class="control-item" id="hold">
                <span class="control-symbol">↔</span>
                <span class="control-word" id="holdWord">HOLD</span>
            </div>
        </div>

        <div class="history-panel">
            <div class="history-header">
                <span>Game History</span>
            </div>
            <div class="sort-buttons">
                <button class="sort-button active" onclick="sortHistory('time')">Time</button>
                <button class="sort-button" onclick="sortHistory('score')">Score</button>
                <button class="sort-button" onclick="sortHistory('lines')">Lines</button>
                <button class="sort-button" onclick="sortHistory('blocks')">Blocks</button>
            </div>
            <div class="history-list" id="historyList">
                <div style="opacity: 0.5; text-align: center; padding: 20px;">No games yet</div>
            </div>
        </div>
    </div>

    <div class="start-screen" id="startScreen">
        <h1>WORD TETRIS</h1>
        <p>Type 4-letter words to control the pieces</p>
        <button class="button" onclick="startGame()">Start Game</button>
    </div>

    <div class="pause-menu" id="pauseMenu">
        <button class="button" onclick="resumeGame()">Resume</button>
        <button class="button" onclick="restartGame()">Restart</button>
        <button class="button" onclick="endGame()">End Game</button>
    </div>

    <div class="game-over" id="gameOver">
        <div>GAME OVER</div>
        <div>Final Score: <span id="finalScore">0</span></div>
        <button class="button" onclick="resetGame()">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');
        const BLOCK_SIZE = 30;
        const COLS = 10;
        const ROWS = 20;

        // Fixed word list for reliability (4-letter words)
        const allWords = ["ABLE","ABLY","ABUT","ACHE","ACHY","ACID","ACME","ACNE","ACRE","AGED","AHEM","AIDE","AILS","AIMS","AIRS","AIRY","AJAR","AKIN","ALAS","ALLY","ALMS","ALOE","ALSO","ALTO","ALUM","AMID","AMOK","AMPS","ANDS","ANEW","ANKH","ANNA","ANTE","ANTI","ANTS","ANUS","APEX","AQUA","ARCH","AREA","ARIA","ARID","ARMS","ARMY","ARTY","ASHY","ASKS","ATOM","ATOP","AUNT","AURA","AUTO","AVID","AVOW","AWAY","AWED","AXES","AXIS","AXLE","AYES","BABE","BABY","BACK","BADE","BAGS","BAIT","BAKE","BALD","BALE","BALL","BALM","BAND","BANE","BANG","BANK","BARB","BARD","BARE","BARK","BARN","BARS","BASE","BASH","BASK","BASS","BATS","BAWL","BAYS","BEAD","BEAK","BEAM","BEAN","BEAR","BEAT","BEDS","BEEP","BEER","BEES","BEET","BELL","BELT","BEND","BENT","BERG","BEST","BETA","BIAS","BIBS","BIDS","BIKE","BILE","BILL","BIND","BINS","BIRD","BITE","BITS","BLAH","BLAT","BLED","BLEW","BLIP","BLOB","BLOC","BLOT","BLOW","BLUE","BLUR","BOAR","BOAS","BOAT","BOBS","BODE","BODS","BODY","BOGS","BOIL","BOLD","BOLT","BOMB","BOND","BONE","BONG","BONK","BONY","BOOB","BOOK","BOOM","BOON","BOOR","BOOS","BOOT","BORE","BORN","BOSS","BOTH","BOUT","BOWL","BOWS","BOYS","BRAD","BRAG","BRAN","BRAS","BRAT","BRAY","BRED","BREW","BRIE","BRIM","BROW","BRUT","BUBO","BUBS","BUCK","BUDS","BUFF","BUGS","BULB","BULK","BULL","BUMS","BUMP","BUNK","BUNS","BUOY","BURB","BURG","BURN","BURP","BURR","BURY","BUSH","BUSK","BUSS","BUST","BUSY","BUTT","BUYS","BUZZ","BYTE","CABS","CADS","CAFE","CAGE","CAKE","CALF","CALL","CALM","CAME","CAMP","CAMS","CANE","CANS","CANT","CAPE","CAPS","CARD","CARE","CARP","CARS","CART","CASE","CASH","CASK","CAST","CATS","CAVE","CEDE","CELL","CENT","CHAP","CHAR","CHAT","CHEF","CHEW","CHIC","CHIN","CHIP","CHIT","CHOP","CHOW","CHUB","CHUG","CHUM","CITE","CITY","CLAD","CLAM","CLAN","CLAP","CLAW","CLAY","CLEF","CLIP","CLOD","CLOG","CLOP","CLOT","CLUB","CLUE","COAL","COAT","COAX","COBS","COCA","COCK","CODA","CODE","CODS","COED","COGS","COIL","COIN","COKE","COLA","COLD","COLE","COLT","COMA","COMB","COME","CONE","CONK","CONS","CONY","COOK","COOL","COOP","COOS","COOT","COPE","COPS","COPY","CORD","CORE","CORK","CORN","COSH","COSS","COST","COSY","COTE","COTS","COUP","COVE","COWS","COZY","CRAB","CRAM","CRAW","CREW","CRIB","CROP","CROW","CRUD","CRUX","CUBE","CUBS","CUDS","CUED","CUES","CUFF","CULL","CULT","CUPS","CURB","CURD","CURE","CURL","CURS","CURT","CUSP","CUSS","CUTE","CUTS","CWMS","CYAN","CYST","CZAR","DABS","DACE","DADS","DAFT","DAIS","DALE","DAME","DAMN","DAMP","DAMS","DANE","DANG","DANK","DARE","DARK","DARN","DART","DASH","DATA","DATE","DAUB","DAWN","DAYS","DAZE","DEAD","DEAF","DEAL","DEAN","DEAR","DEBT","DECK","DEED","DEEM","DEEP","DEER","DEFT","DEFY","DELI","DELL","DEMO","DENS","DENT","DENY","DESK","DEVA","DEWS","DEWY","DIAL","DICE","DIED","DIES","DIET","DIGS","DIKE","DILL","DIME","DIMS","DINE","DING","DINK","DINS","DINT","DIPS","DIRE","DIRK","DIRT","DISC","DISH","DISK","DIVA","DIVE","DOCK","DODO","DOER","DOES","DOFF","DOGE","DOGS","DOIT","DOLE","DOLL","DOLT","DOME","DONE","DOOM","DOOR","DOPE","DORK","DORM","DORY","DOSE","DOTE","DOTS","DOUR","DOVE","DOWN","DOZE","DOZY","DRAB","DRAG","DRAM","DRAT","DRAW","DRAY","DREW","DRIB","DRIP","DROP","DRUB","DRUG","DRUM","DUAL","DUBS","DUCK","DUCT","DUDE","DUDS","DUEL","DUES","DUET","DUFF","DUKE","DULL","DULY","DUMB","DUMP","DUNE","DUNG","DUNK","DUPE","DUSK","DUST","DUTY","DYAD","DYED","DYER","DYES","DYKE","EACH","EARL","EARN","EARS","EASE","EAST","EASY","EATS","EAVE","EBBS","EBON","ECHO","ECRU","EDDY","EDGE","EDGY","EDIT","EELS","EFTS","EGAD","EGGS","EGOS","EKED","EKES","ELAN","ELLS","ELMS","ELSE","EMIR","EMIT","EMUS","ENDS","ENVY","EONS","EPIC","ERAS","ERGO","ERGS","ERRS","EURO","EVEN","EVER","EVES","EVIL","EWER","EWES","EXAM","EXEC","EXES","EXIT","EXPO","EYED","EYES","FACE","FACT","FADE","FADS","FAIL","FAIN","FAIR","FAKE","FALL","FAME","FANG","FANS","FARE","FARM","FAST","FATE","FATS","FAUN","FAUX","FAWN","FAYS","FAZE","FEAR","FEAT","FEDS","FEED","FEEL","FEES","FEET","FELL","FELT","FEND","FENS","FERN","FESS","FEST","FETA","FEUD","FEWS","FIAT","FIBS","FIEF","FIFE","FIGS","FILE","FILL","FILM","FILS","FIND","FINE","FINK","FINS","FIRE","FIRM","FIRS","FISH","FIST","FITS","FIVE","FIZZ","FLAG","FLAK","FLAM","FLAN","FLAP","FLAT","FLAW","FLAX","FLAY","FLEA","FLED","FLEE","FLEW","FLEX","FLIP","FLIT","FLOE","FLOG","FLOP","FLOW","FLUB","FLUE","FLUX","FOAL","FOAM","FOBS","FOCI","FOES","FOGS","FOGY","FOIL","FOLD","FOLK","FOND","FONT","FOOD","FOOL","FOOT","FOPS","FORA","FORD","FORE","FORK","FORM","FORT","FOUL","FOUR","FOWL","FOXY","FRAE","FRAT","FRAY","FREE","FRET","FRIG","FRIT","FROG","FROM","FROW","FRUG","FUBS","FUEL","FUGS","FULL","FUME","FUMS","FUND","FUNK","FUNS","FURL","FURS","FURY","FUSE","FUSS","FUTZ","FUZE","FUZZ","GABS","GAFF","GAGA","GAGE","GAGS","GAIN","GAIT","GALA","GALE","GALL","GALS","GAME","GAMS","GANG","GAPE","GAPS","GARB","GASH","GASP","GATE","GATS","GAVE","GAWK","GAYS","GAZE","GEAR","GECK","GEED","GEEK","GEES","GEEZ","GELD","GELS","GEMS","GENE","GENS","GENT","GERM","GETS","GIBE","GIFT","GIGS","GILD","GILL","GILT","GIMP","GINS","GIRD","GIRL","GIRT","GIST","GIVE","GLAD","GLAM","GLED","GLEE","GLEN","GLIB","GLIM","GLOB","GLOM","GLOP","GLOW","GLUE","GLUG","GLUM","GLUT","GNAR","GNAT","GNAW","GNUS","GOAD","GOAL","GOAT","GOBS","GODS","GOER","GOES","GOLD","GOLF","GONE","GONG","GOOD","GOOF","GOON","GOOP","GORE","GORY","GOSH","GOTH","GOUT","GOWN","GRAB","GRAD","GRAM","GRAN","GRAY","GREW","GREY","GRID","GRIM","GRIN","GRIP","GRIT","GROG","GROT","GROW","GRUB","GRUE","GULF","GULL","GULP","GUMS","GUNK","GUNS","GURU","GUSH","GUST","GUTS","GUYS","GYMS","GYRE","GYRO","HACK","HAFT","HAGS","HAHA","HAIL","HAIR","HAJI","HAJJ","HAKE","HALE","HALF","HALL","HALO","HALT","HAMS","HAND","HANG","HANK","HAPS","HARD","HARE","HARK","HARM","HARP","HART","HASH","HASP","HATE","HATH","HATS","HAUL","HAVE","HAWK","HAWS","HAYS","HAZE","HAZY","HEAD","HEAL","HEAP","HEAR","HEAT","HECK","HEED","HEEL","HEFT","HEIR","HELD","HELL","HELM","HELP","HEMS","HENS","HERB","HERD","HERE","HERO","HERS","HEST","HEWS","HICK","HIDE","HIGH","HIKE","HILL","HILT","HIMS","HIND","HINT","HIPS","HIRE","HISS","HITS","HIVE","HOAR","HOAX","HOBO","HOBS","HOCK","HODS","HOED","HOER","HOES","HOGS","HOLD","HOLE","HOLY","HOME","HONE","HONK","HOOD","HOOF","HOOK","HOOP","HOOT","HOPE","HOPS","HORN","HOSE","HOST","HOTS","HOUR","HOVE","HOWL","HOYA","HUBS","HUED","HUES","HUFF","HUGE","HUGS","HULA","HULK","HULL","HUMA","HUMP","HUMS","HUNG","HUNK","HUNT","HURL","HURT","HUSH","HUSK","HUTS","HYMN","HYPE","HYPO","IBEX","IBIS","ICED","ICES","ICKY","ICON","IDEA","IDEM","IDES","IDLE","IDLY","IDOL","IFFY","IGLU","IAMB","IKON","ILEA","ILEX","ILKS","ILLS","IMAM","IMPS","INCA","INCH","INFO","INKS","INKY","INNS","INTO","IONS","IOTA","IRIS","IRON","ISLE","ISMS","ITCH","ITEM","JABS","JACK","JADE","JAGS","JAIL","JAKE","JAMS","JANE","JAPE","JARS","JAVA","JAWS","JAYS","JAZZ","JEAN","JEEP","JEER","JEFE","JELL","JERK","JEST","JETS","JIBE","JIBS","JIFF","JIGS","JILT","JINK","JINN","JINX","JIVE","JOBS","JOCK","JOEY","JOGS","JOIN","JOKE","JOLT","JOSH","JOTS","JOWL","JOYS","JUDO","JUGA","JUGS","JUKE","JULY","JUMP","JUNE","JUNK","JUPE","JURY","JUST","JUTE","JUTS","KALE","KART","KAVA","KAYO","KAYS","KECK","KEDS","KEEL","KEEN","KEEP","KEGS","KELP","KENS","KEPT","KERB","KERN","KEYS","KHAN","KICK","KIDS","KILL","KILN","KILO","KILT","KIND","KINE","KING","KINK","KIPS","KIRK","KISS","KITE","KITH","KITS","KIWI","KNEE","KNEW","KNIT","KNOB","KNOT","KNOW","KOAN","KOBS","KOEL","KOHL","KOLA","KOOK","KOPH","KOPS","KORA","KORS","KOTO","KRIS","KUDO","KUDU","KVAS","KYAK","KYTE","LABS","LACE","LACK","LACY","LADS","LADY","LAGS","LAID","LAIN","LAIR","LAKE","LAMA","LAMB","LAME","LAMP","LAND","LANE","LANK","LAPS","LARD","LARK","LASH","LASS","LAST","LATE","LATH","LAUD","LAVA","LAVE","LAWN","LAWS","LAYS","LAZE","LAZY","LEAD","LEAF","LEAK","LEAN","LEAP","LEAS","LECH","LEDE","LEES","LEFT","LEGS","LEIS","LEND","LENS","LENT","LEPT","LESS","LEST","LETS","LEVA","LEVY","LEWD","LIAR","LIBS","LICE","LICK","LIDO","LIDS","LIED","LIEN","LIES","LIEU","LIFE","LIFT","LIKE","LILT","LILY","LIMA","LIMB","LIME","LIMN","LIMO","LIMP","LINE","LING","LINK","LINO","LINT","LION","LIPS","LIRA","LIRE","LIST","LITE","LITS","LIVE","LOAD","LOAF","LOAM","LOAN","LOBE","LOBS","LOCA","LOCH","LOCI","LOCK","LOCO","LODE","LOFT","LOGE","LOGO","LOGS","LOIN","LOLL","LONE","LONG","LOOK","LOOM","LOON","LOOP","LOOS","LOOT","LOPE","LOPS","LORD","LORE","LORN","LORY","LOSE","LOSS","LOST","LOTA","LOTH","LOTS","LOUD","LOUR","LOUT","LOVE","LOWS","LUAU","LUBE","LUCE","LUCK","LUDO","LUFF","LUGE","LUGS","LULL","LULU","LUMP","LUMS","LUNG","LUNK","LURE","LURK","LUSH","LUST","LUTE","LUTZ","LUXE","LYNX","LYRE","MACE","MACH","MADE","MADS","MAGE","MAGI","MAGS","MAID","MAIL","MAIM","MAIN","MAKE","MALE","MALL","MALT","MAMA","MAMS","MANE","MANS","MANY","MAPS","MARC","MARE","MARK","MARL","MARS","MART","MASH","MASK","MASS","MAST","MATE","MATH","MATS","MATT","MAUL","MAUT","MAWS","MAXI","MAYA","MAYO","MAYS","MAZE","MAZY","MEAD","MEAL","MEAN","MEAT","MECK","MEED","MEEK","MEET","MEGA","MELD","MELL","MELT","MEMO","MEMS","MEND","MENS","MENU","MEOW","MERE","MESA","MESH","MESS","META","METE","METH","MEWS","MICA","MICE","MIDI","MIDS","MIEN","MIFF","MIKE","MILD","MILE","MILK","MILL","MILO","MILT","MIME","MIND","MINE","MINI","MINK","MINT","MINX","MIRE","MIRS","MISE","MISO","MISS","MIST","MITE","MITT","MOAN","MOAT","MOBS","MOCK","MODE","MODS","MOIL","MOJO","MOKE","MOLD","MOLE","MOLL","MOLT","MOLY","MOMS","MONK","MONO","MONS","MOOD","MOON","MOOR","MOOS","MOOT","MOPE","MOPS","MORE","MORN","MORT","MOSS","MOST","MOTE","MOTH","MOTS","MOVE","MOWN","MOWS","MUCH","MUCK","MUDS","MUFF","MUGS","MULE","MULL","MUMM","MUMS","MUMP","MUNG","MUNI","MUON","MURK","MUSE","MUSH","MUSK","MUSS","MUST","MUTE","MUTT","MYTH","NABS","NADA","NAFF","NAGS","NAIF","NAIL","NAME","NANA","NANS","NAPE","NAPS","NARC","NARD","NARK","NARY","NAVE","NAVY","NAYS","NAZI","NEAP","NEAR","NEAT","NECK","NEED","NEEM","NEEP","NEMA","NENE","NEON","NERD","NESS","NEST","NETS","NEUK","NEUM","NEWS","NEWT","NEXT","NICE","NICK","NIGH","NILS","NINE","NIPA","NIPS","NITE","NITS","NIXE","NIXY","NOBS","NOCK","NODE","NODI","NODS","NOEL","NOES","NOGG","NOGS","NOIL","NOIR","NOMA","NOME","NOMS","NONA","NONE","NOOK","NOON","NOPE","NORI","NORM","NOSE","NOSH","NOSY","NOTE","NOUN","NOUS","NOVA","NUBS","NUDE","NUKE","NULL","NUMB","NUNS","NURD","NURL","NURS","NUTS","OAFS","OAKS","OARS","OATH","OATS","OBEY","OBIS","OBOE","OBOL","ODDS","ODEA","ODES","ODIC","ODOR","ODYL","OFFS","OGEE","OGLE","OGRE","OHED","OHMS","OILS","OILY","OINK","OKAS","OKAY","OKRA","OLDS","OLEA","OLEO","OLES","OLIO","OMEN","OMER","OMIT","ONCE","ONES","ONLY","ONTO","ONUS","OOHS","OOPS","OOZE","OOZY","OPAH","OPAL","OPED","OPEN","OPES","OPTS","OPUS","ORAL","ORBS","ORCA","ORCS","ORES","ORGY","ORLE","ORRA","ORTS","ORYX","ORZO","OSAR","OSSA","OTIC","OTTO","OUCH","OURS","OUST","OUTS","OUZO","OVAL","OVEN","OVER","OWED","OWES","OWLS","OWNS","OXEN","OXES","OXIC","OXID","OXIM","OYER","OYES","OYEZ","PACA","PACE","PACK","PACS","PACT","PADS","PAGE","PAID","PAIK","PAIL","PAIN","PAIR","PALE","PALL","PALM","PALP","PALS","PALY","PAMS","PANE","PANG","PANS","PANT","PAPA","PAPS","PARA","PARD","PARE","PARK","PARR","PARS","PART","PASE","PASS","PAST","PATE","PATH","PATS","PAVE","PAWL","PAWN","PAWS","PAYS","PEAK","PEAL","PEAN","PEAR","PEAS","PEAT","PEBA","PECK","PECS","PEDS","PEED","PEEK","PEEL","PEEN","PEEP","PEER","PEES","PEGS","PEHS","PEIN","PEKE","PELE","PELF","PELL","PELT","PEND","PENS","PENT","PEON","PEPO","PEPS","PERK","PERM","PERT","PESO","PEST","PETS","PEWS","PFUI","PHAT","PHEW","PHIS","PHIZ","PHOD","PHON","PHOT","PHUT","PIAL","PIAN","PIAS","PICA","PICE","PICK","PICS","PIED","PIER","PIES","PIGS","PIKA","PIKE","PIKI","PILE","PILI","PILL","PILY","PIMA","PIMP","PINA","PINE","PING","PINK","PINS","PINT","PINY","PION","PIPA","PIPE","PIPS","PIPY","PIRN","PISO","PISS","PITA","PITH","PITS","PITY","PIXY","PLAN","PLAT","PLAY","PLEA","PLEB","PLED","PLEW","PLIE","PLOD","PLOP","PLOT","PLOW","PLOY","PLUG","PLUM","PLUS","POCK","PODS","POEM","POET","POGY","POIS","POKE","POKY","POLE","POLL","POLO","POLS","POLY","POME","POMP","POMS","POND","PONE","PONG","PONS","PONY","POOD","POOF","POOH","POOL","POOP","POOR","POOS","POPE","POPS","PORE","PORK","PORN","PORT","POSE","POSH","POST","POSY","POTS","POUR","POUT","POWS","POXY","PRAM","PRAO","PRAT","PRAU","PRAY","PREE","PREP","PREY","PREZ","PRIG","PRIM","PROA","PROB","PROD","PROF","PROG","PROM","PROP","PROS","PROW","PRUH","PRYS","PSIS","PSST","PUCE","PUCK","PUDS","PUFF","PUGH","PUGS","PUJA","PUKE","PULA","PULE","PULI","PULL","PULP","PULS","PUMA","PUMP","PUNK","PUNS","PUNY","PUPA","PUPS","PUPU","PURE","PURI","PURL","PURR","PURS","PUSH","PUSS","PUTS","PUTT","PUTZ","PUYS","PYAS","PYES","PYIN","PYRE","PYRO","QADI","QAID","QATS","QOPH","QUAG","QUAI","QUAY","QUEY","QUID","QUIN","QUIP","QUIT","QUIZ","QUOD","RACE","RACK","RACY","RADS","RAFT","RAGA","RAGE","RAGS","RAIA","RAID","RAIL","RAIN","RAJA","RAKE","RAKI","RAKU","RALA","RALE","RAMI","RAMP","RAMS","RAND","RANG","RANI","RANK","RANT","RAPE","RAPS","RAPT","RARE","RASE","RASH","RASP","RATE","RATH","RATS","RAVE","RAWS","RAYA","RAYS","RAZE","RAZZ","READ","REAL","REAM","REAP","REAR","REBS","RECK","RECS","REDD","REDS","REED","REEF","REEK","REEL","REFS","REFT","REGS","REIN","REIS","RELY","REMS","REND","RENT","REPO","REPP","REPS","REST","RETE","RETS","REVS","RHEA","RHOS","RIAD","RIAL","RIAS","RIBS","RICE","RICH","RICK","RIDE","RIDS","RIEL","RIFE","RIFF","RIFT","RIGS","RILE","RILL","RIME","RIMS","RIMY","RIND","RING","RINK","RINS","RIOT","RIPE","RIPS","RISE","RISK","RITE","RITZ","RIVE","ROAD","ROAM","ROAN","ROAR","ROBE","ROBS","ROCK","ROCS","RODE","RODS","ROES","ROIL","ROLE","ROLF","ROLL","ROMP","ROMS","ROOD","ROOF","ROOK","ROOM","ROOT","ROPE","ROPY","ROSE","ROSY","ROTA","ROTE","ROTI","ROTL","ROTO","ROTS","ROUE","ROUP","ROUT","ROUX","ROVE","ROWS","RUBE","RUBS","RUBY","RUCK","RUDD","RUDE","RUED","RUER","RUES","RUFF","RUGA","RUGS","RUIN","RUKH","RULE","RULY","RUMP","RUMS","RUNE","RUNG","RUNS","RUNT","RUSE","RUSH","RUSK","RUST","RUTH","RUTS","RYAS","RYES","RYKE","RYND","RYOT","SABE","SABS","SACK","SACS","SADE","SADI","SAFE","SAGA","SAGE","SAGO","SAGS","SAGY","SAID","SAIL","SAIM","SAIN","SAKE","SAKI","SALE","SALL","SALP","SALS","SALT","SAMA","SAME","SAMP","SAND","SANE","SANG","SANK","SANS","SAPS","SARD","SARI","SARK","SASH","SASS","SATE","SATI","SAUL","SAVE","SAWN","SAWS","SAYS","SCAB","SCAD","SCAG","SCAM","SCAN","SCAR","SCAT","SCOP","SCOT","SCOW","SCRY","SCUD","SCUM","SEAL","SEAM","SEAR","SEAS","SEAT","SECS","SECT","SEED","SEEK","SEEL","SEEM","SEEN","SEEP","SEER","SEES","SEGO","SEGS","SEIF","SEIS","SELF","SELL","SELS","SEME","SEMI","SEND","SENE","SENT","SEPT","SERA","SERB","SERE","SERF","SERS","SESS","SETA","SETS","SETT","SEWN","SEWS","SEXY","SHAD","SHAG","SHAH","SHAM","SHAW","SHAY","SHEA","SHED","SHEW","SHIM","SHIN","SHIP","SHIV","SHMO","SHOD","SHOE","SHOG","SHOO","SHOP","SHOT","SHOW","SHRI","SHUL","SHUN","SHUT","SHWA","SICK","SIDE","SIDS","SIFT","SIGH","SIGN","SIKA","SIKE","SILD","SILK","SILL","SILO","SILT","SIMA","SIMP","SIMS","SINE","SING","SINH","SINK","SINS","SIPE","SIPS","SIRE","SIRS","SISE","SISS","SITE","SITH","SITS","SIZE","SIZY","SKAG","SKAS","SKAT","SKEE","SKEG","SKEP","SKEW","SKID","SKIM","SKIN","SKIP","SKIS","SKIT","SKUA","SKYP","SLAB","SLAG","SLAM","SLAP","SLAT","SLAW","SLAY","SLED","SLEW","SLID","SLIM","SLIP","SLIT","SLOB","SLOE","SLOG","SLOP","SLOT","SLOW","SLUB","SLUE","SLUG","SLUM","SLUR","SLUT","SMEW","SMIT","SMOG","SMUG","SMUT","SNAG","SNAP","SNAW","SNED","SNIB","SNIP","SNIT","SNOB","SNOG","SNOT","SNOW","SNUB","SNUG","SNYE","SOAK","SOAP","SOAR","SOBA","SOBS","SOCK","SODA","SODS","SOFA","SOFT","SOGS","SOIL","SOJA","SOKE","SOLA","SOLD","SOLE","SOLI","SOLO","SOLS","SOMA","SOME","SOMS","SONS","SONE","SONG","SOON","SOOT","SOPH","SOPS","SORA","SORB","SORD","SORE","SORI","SORN","SORT","SOSS","SOTH","SOTS","SOUK","SOUL","SOUP","SOUR","SOUS","SOWN","SOWS","SOYA","SOYS","SPAE","SPAM","SPAN","SPAR","SPAS","SPAT","SPAY","SPEC","SPED","SPEW","SPIC","SPIK","SPIN","SPIT","SPIV","SPOT","SPRY","SPUD","SPUE","SPUN","SPUR","STAB","STAG","STAR","STAT","STAW","STAY","STEM","STEP","STET","STEW","STIR","STOA","STOB","STOP","STOW","STUB","STUD","STUM","STUN","STYE","STYX","SUBA","SUBE","SUBS","SUCH","SUCK","SUDD","SUDS","SUED","SUER","SUES","SUET","SUIT","SUKS","SULK","SUMA","SUMO","SUMP","SUMS","SUNG","SUNK","SUNN","SUNS","SUPE","SUPS","SUQS","SURA","SURD","SURE","SURF","SUSS","SWAB","SWAG","SWAM","SWAN","SWAP","SWAT","SWAY","SWIG","SWIM","SWOB","SWOP","SWOT","SWUM","SYBO","SYCE","SYKE","SYLI","SYNC","SYNE","SYPH","TABS","TABU","TACE","TACH","TACK","TACO","TACT","TADS","TAEL","TAGS","TAHR","TAIL","TAIN","TAKA","TAKE","TALA","TALC","TALE","TALI","TALK","TALL","TAME","TAMP","TAMS","TANG","TANK","TANS","TAOS","TAPA","TAPE","TAPS","TARE","TARN","TARO","TARP","TARS","TART","TASK","TASS","TATE","TATS","TAUS","TAUT","TAVA","TAVS","TAWS","TAXA","TAXI","TEAK","TEAL","TEAM","TEAR","TEAS","TEAT","TECH","TEDS","TEED","TEEL","TEEM","TEEN","TEES","TEFF","TEGG","TEGS","TELA","TELE","TELL","TELS","TEME","TEMP","TEND","TENS","TENT","TEPA","TERM","TERN","TEST","TETH","TETS","TEWS","TEXT","THAE","THAN","THAT","THAW","THEE","THEM","THEN","THEW","THEY","THIN","THIS","THOU","THRO","THRU","THUD","THUG","THUS","TICK","TICS","TIDE","TIDY","TIED","TIER","TIES","TIFF","TIGS","TIKE","TIKI","TILE","TILL","TILS","TILT","TIME","TINE","TING","TINS","TINT","TINY","TIPI","TIPS","TIRE","TIRO","TITI","TITS","TIVY","TOAD","TOBE","TOBY","TOCK","TOCS","TODA","TODS","TODY","TOED","TOES","TOFF","TOFT","TOFU","TOGA","TOGS","TOIL","TOIT","TOKE","TOLA","TOLD","TOLE","TOLL","TOLU","TOMB","TOME","TOMS","TONE","TONG","TONS","TONY","TOOK","TOOL","TOOM","TOON","TOOT","TOPE","TOPH","TOPI","TOPS","TORA","TORC","TORE","TORI","TORN","TORO","TORR","TORT","TORY","TOSA","TOSH","TOSS","TOST","TOTE","TOTS","TOUR","TOUT","TOWN","TOWS","TOWY","TOYS","TRAD","TRAM","TRAP","TRAY","TREE","TREF","TREK","TRES","TRET","TREY","TRIG","TRIM","TRIO","TRIP","TROD","TROG","TROP","TROT","TROW","TROY","TRUE","TRUG","TSAR","TSKS","TUBA","TUBE","TUBS","TUCK","TUFA","TUFF","TUFT","TUGS","TUIS","TULE","TUMP","TUMS","TUNA","TUNE","TUNG","TUNS","TUPA","TUPS","TURD","TURF","TURK","TURN","TUSH","TUSK","TUTS","TUTU","TUVA","TUYO","TWAE","TWAS","TWAT","TWEE","TWIG","TWIN","TWIT","TWOS","TYEE","TYER","TYES","TYKE","TYNE","TYPE","TYPO","TYPP","TYPY","TYRE","TYRO","TZAR","UDON","UDOS","UGHS","UGLY","UKES","ULAN","ULNA","ULUS","ULVA","UMBO","UMPS","UNAI","UNAU","UNBE","UNCI","UNCO","UNDE","UNDO","UNDY","UNIS","UNIT","UNTO","UPAS","UPBY","UPDO","UPON","URBS","URDS","UREA","URGE","URIC","URNS","URPS","URSA","URUS","USED","USER","USES","UTAS","UTES","UTIS","UVEA","VACS","VAGI","VAIL","VAIN","VAIR","VALE","VALI","VAMP","VANE","VANG","VANS","VARA","VARS","VARY","VASE","VAST","VATS","VATU","VAUS","VAVS","VAWS","VEAL","VEEP","VEER","VEES","VEIL","VEIN","VELA","VELD","VENA","VEND","VENT","VERA","VERB","VERT","VERY","VEST","VETO","VETS","VEXT","VIAL","VIAS","VIBE","VICE","VIDE","VIED","VIER","VIES","VIEW","VIGS","VILE","VILL","VIMS","VINA","VINE","VINO","VINS","VINY","VIOL","VIRL","VISA","VISE","VITA","VIVA","VIVE","VIVO","VIZS","VOCE","VOES","VOID","VOLE","VOLT","VOTE","VOWS","VROW","VUGG","VUGH","VUGS","WABS","WACK","WACS","WADE","WADI","WADS","WADY","WAFF","WAFT","WAGE","WAGS","WAIF","WAIL","WAIN","WAIR","WAIT","WAKE","WALE","WALK","WALL","WALY","WAME","WAND","WANE","WANK","WANS","WANT","WANY","WAPS","WARD","WARE","WARK","WARM","WARN","WARP","WARS","WART","WARY","WASH","WASP","WAST","WATE","WATS","WATT","WAUL","WAUR","WAVE","WAVY","WAWL","WAWS","WAXY","WAYS","WEAK","WEAL","WEAN","WEAR","WEBS","WEDS","WEED","WEEK","WEEL","WEEN","WEEP","WEER","WEES","WEET","WEFT","WEIR","WEKA","WELD","WELL","WELT","WEND","WENS","WENT","WEPT","WERE","WERT","WEST","WETS","WEYS","WHAM","WHAP","WHAT","WHEE","WHEN","WHET","WHEW","WHEY","WHIG","WHIM","WHIN","WHIP","WHIR","WHIT","WHIZ","WHOA","WHOM","WHOP","WHUP","WHYS","WICH","WICK","WIDE","WIFE","WIGS","WILD","WILE","WILL","WILT","WILY","WIMP","WIND","WINE","WING","WINK","WINO","WINS","WINY","WIPE","WIRE","WIRY","WISE","WISH","WISP","WISS","WIST","WITH","WITS","WIVE","WOAD","WOES","WOGS","WOKE","WOKS","WOLD","WOLF","WOMB","WONS","WONT","WOOD","WOOF","WOOL","WOOS","WOPS","WORD","WORE","WORK","WORM","WORN","WORT","WOST","WOTS","WOVE","WOWS","WRAP","WREN","WRIT","WUSS","WYCH","WYES","WYNN","WYNS","WYTE","XYST","YACK","YAFF","YAGI","YAKS","YALD","YAMS","YANG","YANK","YAPS","YARD","YARE","YARN","YAUD","YAUP","YAWL","YAWN","YAWP","YAWS","YAYS","YEAH","YEAN","YEAR","YEAS","YECH","YEGG","YELD","YELK","YELL","YELP","YENS","YEPS","YERK","YETI","YETT","YEUK","YEWS","YIDS","YILL","YINS","YIPE","YIPS","YIRD","YIRR","YLEM","YOBS","YOCK","YODH","YODS","YOGA","YOGH","YOGI","YOKE","YOKS","YOLK","YOND","YONI","YOOF","YORE","YOUR","YOUS","YOWE","YOWL","YOWS","YUAN","YUCA","YUCH","YUCK","YUKS","YULE","YURT","YWIS","ZAGS","ZANY","ZAPS","ZARF","ZEAL","ZEBU","ZEDS","ZEES","ZEIN","ZEKE","ZEKS","ZENS","ZEPS","ZERK","ZERO","ZEST","ZETA","ZIGS","ZINC","ZINE","ZING","ZINS","ZIPS","ZITI","ZITS","ZIZZ","ZOEA","ZOIC","ZONA","ZONE","ZONK","ZOOM","ZOON","ZOOS","ZORI","ZULU","ZYME"];

        // Shuffle array helper
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Word pools for each action
        let wordPools = {
            rotateLeft: [],
            rotateRight: [],
            moveLeft: [],
            moveRight: [],
            moveDown: [],
            hardDrop: [],
            hold: []
        };

        // Initialize word pools from fixed list
        function initializeWords() {
            const shuffled = shuffleArray(allWords);
            const wordsPerAction = Math.floor(shuffled.length / 7);
            
            const actions = Object.keys(wordPools);
            actions.forEach((action, i) => {
                const start = i * wordsPerAction;
                const end = start + wordsPerAction;
                wordPools[action] = shuffled.slice(start, end);
            });
        }

        // Game state
        let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        let score = 0;
        let lines = 0;
        let level = 1;
        let gameOver = false;
        let inputBuffer = '';
        let currentPiece = null;
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let currentTheme = 0;
        const themes = ['theme-dark', 'theme-purple', 'theme-blue', 'theme-red'];
        let clearingLines = [];
        let clearAnimationFrame = 0;
        let highScore = parseInt(localStorage.getItem('wordTetrisHighScore') || '0');
        let heldPiece = null;
        let canHold = true;
        let onGround = false;
        let groundTicks = 0;
        let charCount = 0;
        let gameStartTime = null;
        let transitionCells = []; // Array of {x, y, targetColor, startTime, duration}
        let isPaused = false;
        let isGameStarted = false;
        let blocksPlaced = 0;
        let gameHistory = JSON.parse(localStorage.getItem('wordTetrisHistory') || '[]');
        let currentSortBy = 'time';

        // Current words for each action
        let currentWords = {
            rotateLeft: 'SPIN',
            rotateRight: 'TURN',
            moveLeft: 'LEFT',
            moveRight: 'RITE',
            moveDown: 'DOWN',
            hardDrop: 'DROP',
            hold: 'HOLD'
        };

        // Tetromino shapes
        const PIECES = {
            'I': [[1,1,1,1]],
            'O': [[1,1],[1,1]],
            'T': [[0,1,0],[1,1,1]],
            'S': [[0,1,1],[1,1,0]],
            'Z': [[1,1,0],[0,1,1]],
            'J': [[1,0,0],[1,1,1]],
            'L': [[0,0,1],[1,1,1]]
        };

        const COLORS = {
            'I': 'rgb(100, 180, 200)',
            'O': 'rgb(200, 180, 100)',
            'T': 'rgb(160, 100, 180)',
            'S': 'rgb(120, 180, 120)',
            'Z': 'rgb(200, 120, 120)',
            'J': 'rgb(100, 120, 180)',
            'L': 'rgb(200, 150, 100)'
        };

        class Piece {
            constructor() {
                const types = Object.keys(PIECES);
                this.type = types[Math.floor(Math.random() * types.length)];
                this.shape = PIECES[this.type];
                this.color = COLORS[this.type];
                this.x = Math.floor(COLS / 2) - Math.floor(this.shape[0].length / 2);
                this.y = 0;
                this.rotationCount = 0;
            }

            rotate(clockwise = true) {
                const newShape = [];
                if (clockwise) {
                    for (let i = 0; i < this.shape[0].length; i++) {
                        newShape[i] = [];
                        for (let j = this.shape.length - 1; j >= 0; j--) {
                            newShape[i].push(this.shape[j][i]);
                        }
                    }
                } else {
                    for (let i = this.shape[0].length - 1; i >= 0; i--) {
                        newShape[this.shape[0].length - 1 - i] = [];
                        for (let j = 0; j < this.shape.length; j++) {
                            newShape[this.shape[0].length - 1 - i].push(this.shape[j][i]);
                        }
                    }
                }
                
                const oldShape = this.shape;
                const oldX = this.x;
                this.shape = newShape;
                
                // Wall kick
                if (this.collides()) {
                    this.x = oldX - 1;
                    if (this.collides()) {
                        this.x = oldX + 1;
                        if (this.collides()) {
                            this.x = oldX;
                            this.shape = oldShape;
                            return false;
                        }
                    }
                }
                
                this.rotationCount++;
                return true;
            }

            move(dx, dy) {
                this.x += dx;
                this.y += dy;
                
                if (this.collides()) {
                    this.x -= dx;
                    this.y -= dy;
                    return false;
                }
                return true;
            }

            collides() {
                for (let y = 0; y < this.shape.length; y++) {
                    for (let x = 0; x < this.shape[y].length; x++) {
                        if (this.shape[y][x]) {
                            const newX = this.x + x;
                            const newY = this.y + y;
                            
                            if (newX < 0 || newX >= COLS || newY >= ROWS) {
                                return true;
                            }
                            
                            if (newY >= 0 && board[newY][newX]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            isOnGround() {
                for (let y = 0; y < this.shape.length; y++) {
                    for (let x = 0; x < this.shape[y].length; x++) {
                        if (this.shape[y][x]) {
                            const newX = this.x + x;
                            const newY = this.y + y + 1;
                            
                            if (newY >= ROWS) {
                                return true;
                            }
                            
                            if (newY >= 0 && board[newY][newX]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            getDropDistance() {
                let distance = 0;
                while (true) {
                    this.y++;
                    distance++;
                    if (this.collides()) {
                        this.y -= distance;
                        return distance - 1;
                    }
                }
            }
            lock() {
                for (let y = 0; y < this.shape.length; y++) {
                    for (let x = 0; x < this.shape[y].length; x++) {
                        if (this.shape[y][x]) {
                            const boardY = this.y + y;
                            const boardX = this.x + x;
                            if (boardY >= 0) {
                                // Write to board immediately
                                board[boardY][boardX] = this.color;

                                // Keep transition animation
                                transitionCells.push({
                                    x: boardX,
                                    y: boardY,
                                    targetColor: this.color,
                                    startTime: Date.now(),
                                    duration: 100
                                });
                            }
                        }
                    }
                }
            }
        }

        function holdPiece() {
            if (!canHold) return;
            
            if (heldPiece === null) {
                heldPiece = currentPiece.type;
                currentPiece = new Piece();
            } else {
                const temp = heldPiece;
                heldPiece = currentPiece.type;
                currentPiece = new Piece();
                currentPiece.type = temp;
                currentPiece.shape = PIECES[temp];
                currentPiece.color = COLORS[temp];
            }
            
            canHold = false;
            onGround = false;
            groundTicks = 0;
        }

        function saveGameToHistory() {
            const game = {
                timestamp: Date.now(),
                date: new Date().toLocaleString(),
                score: score,
                lines: lines,
                blocks: blocksPlaced,
                cps: document.getElementById('cps').textContent
            };
            
            gameHistory.unshift(game);
            
            // Keep only last 50 games
            if (gameHistory.length > 50) {
                gameHistory = gameHistory.slice(0, 50);
            }
            
            localStorage.setItem('wordTetrisHistory', JSON.stringify(gameHistory));
            renderHistory();
        }

        function renderHistory() {
            const historyList = document.getElementById('historyList');
            
            if (gameHistory.length === 0) {
                historyList.innerHTML = '<div style="opacity: 0.5; text-align: center; padding: 20px;">No games yet</div>';
                return;
            }
            
            historyList.innerHTML = gameHistory.map((game, index) => `
                <div class="history-item">
                    <div class="history-item-row">
                        <strong>#${index + 1}</strong>
                        <span>${game.date}</span>
                    </div>
                    <div class="history-item-row">
                        <span>Score: ${game.score}</span>
                        <span>Lines: ${game.lines}</span>
                    </div>
                    <div class="history-item-row">
                        <span>Blocks: ${game.blocks}</span>
                        <span>CPS: ${game.cps}</span>
                    </div>
                </div>
            `).join('');
        }

        function sortHistory(sortBy) {
            currentSortBy = sortBy;
            
            // Update active button
            document.querySelectorAll('.sort-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Sort the history
            const sorted = [...gameHistory];
            switch(sortBy) {
                case 'time':
                    sorted.sort((a, b) => b.timestamp - a.timestamp);
                    break;
                case 'score':
                    sorted.sort((a, b) => b.score - a.score);
                    break;
                case 'lines':
                    sorted.sort((a, b) => b.lines - a.lines);
                    break;
                case 'blocks':
                    sorted.sort((a, b) => b.blocks - a.blocks);
                    break;
            }
            
            const historyList = document.getElementById('historyList');
            historyList.innerHTML = sorted.map((game, index) => `
                <div class="history-item">
                    <div class="history-item-row">
                        <strong>#${index + 1}</strong>
                        <span>${game.date}</span>
                    </div>
                    <div class="history-item-row">
                        <span>Score: ${game.score}</span>
                        <span>Lines: ${game.lines}</span>
                    </div>
                    <div class="history-item-row">
                        <span>Blocks: ${game.blocks}</span>
                        <span>CPS: ${game.cps}</span>
                    </div>
                </div>
            `).join('');
        }

        function togglePause() {
            if (!isGameStarted || gameOver) return;
            
            isPaused = !isPaused;
            
            if (isPaused) {
                document.getElementById('pauseMenu').classList.add('show');
            } else {
                document.getElementById('pauseMenu').classList.remove('show');
            }
        }

        function resumeGame() {
            isPaused = false;
            document.getElementById('pauseMenu').classList.remove('show');
            lastTime = performance.now();
            requestAnimationFrame(update);
        }

        function restartGame() {
            // Save current game if it has progress
            if (blocksPlaced > 0) {
                saveGameToHistory();
            }
            
            isPaused = false;
            document.getElementById('pauseMenu').classList.remove('show');
            resetGame();
        }

        function endGame() {
            // Save current game if it has progress
            if (blocksPlaced > 0) {
                saveGameToHistory();
            }
            
            isPaused = false;
            isGameStarted = false;
            gameOver = false;
            document.getElementById('pauseMenu').classList.remove('show');
            document.getElementById('startScreen').classList.remove('hidden');
            
            // Clear board
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            currentPiece = null;
            draw();
        }

        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            isGameStarted = true;
            resetGame();
        }

        function getRandomWord(pool, exclude) {
            const available = pool.filter(word => word !== exclude);
            return available[Math.floor(Math.random() * available.length)];
        }

        function updateWord(action) {
            const pool = wordPools[action];
            const newWord = getRandomWord(pool, currentWords[action]);
            currentWords[action] = newWord;
            
            // Wrap each letter in a span for individual highlighting
            const wordElement = document.getElementById(action + 'Word');
            wordElement.innerHTML = newWord.split('').map(letter => 
                `<span class="letter unmatched">${letter}</span>`
            ).join('');
            
            // Highlight the control
            document.getElementById(action).classList.add('highlight');
            setTimeout(() => {
                document.getElementById(action).classList.remove('highlight');
            }, 300);
        }

        function updateLetterHighlights() {
            const buffer = inputBuffer.slice(-4).toUpperCase();
            
            for (const action in currentWords) {
                const word = currentWords[action];
                const wordElement = document.getElementById(action + 'Word');
                const letters = wordElement.querySelectorAll('.letter');
                
                for (let i = 0; i < letters.length; i++) {
                    if (i < buffer.length && buffer[i] === word[i]) {
                        letters[i].classList.remove('unmatched');
                        letters[i].classList.add('matched');
                    } else {
                        letters[i].classList.remove('matched');
                        letters[i].classList.add('unmatched');
                    }
                }
            }
        }

        function checkInput() {
            if (inputBuffer.length < 4) return;
            
            const last4 = inputBuffer.slice(-4).toUpperCase();
            let actionTaken = false;
            let bonusPoints = 0;
            
            if (last4 === currentWords.rotateLeft) {
                const rotated = currentPiece.rotate(false);
                if (rotated) {
                    updateWord('rotateLeft');
                    actionTaken = true;
                    // Check for T-spin potential
                    if (currentPiece.type === 'T' && currentPiece.isOnGround()) {
                        bonusPoints = 100 * level;
                    }
                }
            } else if (last4 === currentWords.rotateRight) {
                const rotated = currentPiece.rotate(true);
                if (rotated) {
                    updateWord('rotateRight');
                    actionTaken = true;
                    // Check for T-spin potential
                    if (currentPiece.type === 'T' && currentPiece.isOnGround()) {
                        bonusPoints = 100 * level;
                    }
                }
            } else if (last4 === currentWords.moveLeft) {
                if (currentPiece.move(-1, 0)) {
                    updateWord('moveLeft');
                    actionTaken = true;
                }
            } else if (last4 === currentWords.moveRight) {
                if (currentPiece.move(1, 0)) {
                    updateWord('moveRight');
                    actionTaken = true;
                }
            } else if (last4 === currentWords.moveDown) {
                if (currentPiece.move(0, 1)) {
                    updateWord('moveDown');
                    actionTaken = true;
                    score += 1;
                }
            } else if (last4 === currentWords.hardDrop) {
                const dropDistance = currentPiece.getDropDistance();
                while (currentPiece.move(0, 1)) {}
                bonusPoints = dropDistance * 2 * level;
                lockPiece();
                updateWord('hardDrop');
                actionTaken = true;
            } else if (last4 === currentWords.hold) {
                holdPiece();
                updateWord('hold');
                actionTaken = true;
            }
            
            if (actionTaken) {
                // Reset ground counter if piece moved off ground
                if (!currentPiece.isOnGround()) {
                    onGround = false;
                    groundTicks = 0;
                }
                
                // Add bonus points
                if (bonusPoints > 0) {
                    score += bonusPoints;
                    document.getElementById('score').textContent = score;
                }
            }
        }

        function lockPiece() {
            currentPiece.lock();
            blocksPlaced++;
            clearLines();
            currentPiece = new Piece();
            canHold = true;
            onGround = false;
            groundTicks = 0;
            
            if (currentPiece.collides()) {
                gameOver = true;
                const gameTime = (Date.now() - gameStartTime) / 1000;
                const cps = (charCount / gameTime).toFixed(1);
                document.getElementById('cps').textContent = cps;
                
                // Save game to history
                saveGameToHistory();
                
                document.getElementById('gameOver').classList.add('show');
                document.getElementById('finalScore').textContent = score;
            }
        }

        function clearLines() {
            const linesToClear = [];
            
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    linesToClear.push(y);
                }
            }
            
            if (linesToClear.length > 0) {
                clearingLines = linesToClear;
                clearAnimationFrame = 0;
                animateLineClear();
            }
        }

        function animateLineClear() {
            if (clearAnimationFrame < 10) {
                clearAnimationFrame++;
                setTimeout(() => {
                    draw();
                    animateLineClear();
                }, 50);
            } else {
                // Actually remove the lines
                clearingLines.sort((a, b) => a - b);
                for (const y of clearingLines) {
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(0));
                }
                
                const linesCleared = clearingLines.length;
                lines += linesCleared;
                score += [0, 100, 300, 500, 800][linesCleared] * level;
                level = Math.floor(lines / 10) + 1;
                dropInterval = Math.max(100, 1000 - (level - 1) * 100);
                
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('wordTetrisHighScore', highScore.toString());
                    document.getElementById('highScore').textContent = highScore;
                }
                
                document.getElementById('score').textContent = score;
                document.getElementById('lines').textContent = lines;
                document.getElementById('level').textContent = level;
                
                clearingLines = [];
                clearAnimationFrame = 0;
            }
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = getComputedStyle(document.body).backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const now = Date.now();
            
            // Process transition cells and update board
            transitionCells = transitionCells.filter(cell => {
                const elapsed = now - cell.startTime;
                if (elapsed >= cell.duration) {
                    board[cell.y][cell.x] = cell.targetColor;
                    return false;
                }
                return true;
            });
            
            // Draw gridlines
            ctx.strokeStyle = getComputedStyle(document.body).color;
            ctx.globalAlpha = 0.1;
            ctx.lineWidth = 1;
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK_SIZE, 0);
                ctx.lineTo(x * BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK_SIZE);
                ctx.lineTo(canvas.width, y * BLOCK_SIZE);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            
            // Draw board with retro scanline effect
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    let cellColor = board[y][x];
                    let isTransitioning = false;
                    let transitionProgress = 1;
                    
                    // Check if this cell is transitioning
                    const transition = transitionCells.find(t => t.x === x && t.y === y);
                    if (transition) {
                        const elapsed = now - transition.startTime;
                        transitionProgress = elapsed / transition.duration;
                        cellColor = transition.targetColor;
                        isTransitioning = true;
                    }
                    
                    if (cellColor) {
                        // Check if this line is being cleared
                        let alpha = 1;
                        if (clearingLines.includes(y)) {
                            alpha = Math.abs(Math.sin(clearAnimationFrame * 0.8)) * 0.8;
                        }
                        
                        // Apply transition effect - start at half opacity with scanlines
                        if (isTransitioning) {
                            alpha *= (0.5 + transitionProgress * 0.5);
                        }
                        
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = cellColor;
                        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                        
                        // Retro scanline effect
                        ctx.globalAlpha = alpha * 0.15;
                        ctx.fillStyle = 'white';
                        for (let scan = 0; scan < BLOCK_SIZE; scan += 2) {
                            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE + scan, BLOCK_SIZE - 1, 1);
                        }
                        ctx.globalAlpha = 1;
                    }
                }
            }
            
            // Draw current piece
            if (currentPiece && clearingLines.length === 0) {
                ctx.fillStyle = currentPiece.color;
                for (let y = 0; y < currentPiece.shape.length; y++) {
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x]) {
                            ctx.fillRect(
                                (currentPiece.x + x) * BLOCK_SIZE,
                                (currentPiece.y + y) * BLOCK_SIZE,
                                BLOCK_SIZE - 1,
                                BLOCK_SIZE - 1
                            );
                            
                            // Retro scanline effect
                            ctx.globalAlpha = 0.15;
                            ctx.fillStyle = 'white';
                            for (let scan = 0; scan < BLOCK_SIZE; scan += 2) {
                                ctx.fillRect(
                                    (currentPiece.x + x) * BLOCK_SIZE,
                                    (currentPiece.y + y) * BLOCK_SIZE + scan,
                                    BLOCK_SIZE - 1,
                                    1
                                );
                            }
                            ctx.globalAlpha = 1;
                            ctx.fillStyle = currentPiece.color;
                        }
                    }
                }
            }
            
            // Draw held piece in top-left corner
            if (heldPiece) {
                const heldShape = PIECES[heldPiece];
                const heldColor = COLORS[heldPiece];
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = heldColor;
                for (let y = 0; y < heldShape.length; y++) {
                    for (let x = 0; x < heldShape[y].length; x++) {
                        if (heldShape[y][x]) {
                            ctx.fillRect(
                                x * 15 + 10,
                                y * 15 + 10,
                                14,
                                14
                            );
                        }
                    }
                }
                ctx.globalAlpha = 1;
            }
        }

        function update(time = 0) {
            if (gameOver || !isGameStarted) return;
            
            if (isPaused) return;
            
            const deltaTime = time - lastTime;
            lastTime = time;
            
            // Update CPS display
            if (gameStartTime) {
                const gameTime = (Date.now() - gameStartTime) / 1000;
                const cps = gameTime > 0 ? (charCount / gameTime).toFixed(1) : '0.0';
                document.getElementById('cps').textContent = cps;
            }
            
            // Don't update game logic during line clear animation
            if (clearingLines.length === 0) {
                dropCounter += deltaTime;
                
                // Check if piece is on ground
                if (currentPiece.isOnGround()) {
                    if (!onGround) {
                        onGround = true;
                        groundTicks = 0;
                    }
                    groundTicks += deltaTime;
                    
                    // Lock after ~0.5 seconds on ground
                    if (groundTicks > 500) {
                        lockPiece();
                        dropCounter = 0;
                    }
                } else {
                    onGround = false;
                    groundTicks = 0;
                }
                
                if (dropCounter > dropInterval && !onGround) {
                    if (!currentPiece.move(0, 1)) {
                        // Just touched ground, start counter
                        onGround = true;
                        groundTicks = 0;
                    }
                    dropCounter = 0;
                }
            }
            
            draw();
            requestAnimationFrame(update);
        }

        async function resetGame() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            score = 0;
            lines = 0;
            level = 1;
            gameOver = false;
            inputBuffer = '';
            dropCounter = 0;
            dropInterval = 1000;
            currentPiece = new Piece();
            clearingLines = [];
            clearAnimationFrame = 0;
            heldPiece = null;
            canHold = true;
            onGround = false;
            groundTicks = 0;
            charCount = 0;
            gameStartTime = Date.now();
            transitionCells = [];
            blocksPlaced = 0;
            isPaused = false;
            
            document.getElementById('score').textContent = score;
            document.getElementById('lines').textContent = lines;
            document.getElementById('level').textContent = level;
            document.getElementById('highScore').textContent = highScore;
            document.getElementById('cps').textContent = '0.0';
            document.getElementById('gameOver').classList.remove('show');
            document.getElementById('inputDisplay').textContent = '';
            
            // Initialize new word pools
            initializeWords();
            
            // Initialize all control words with letter spans
            for (const action in currentWords) {
                updateWord(action);
            }
            
            lastTime = performance.now();
            update();
        }

        function changeTheme() {
            document.body.classList.remove(themes[currentTheme]);
            currentTheme = (currentTheme + 1) % themes.length;
            document.body.classList.add(themes[currentTheme]);
        }

        // Input handling
        document.addEventListener('keydown', (e) => {
            if (!isGameStarted || isPaused || gameOver) return;
            
            if (e.key.length === 1 && e.key.match(/[a-zA-Z]/)) {
                // Start game timer on first keypress
                if (!gameStartTime) {
                    gameStartTime = Date.now();
                }
                
                charCount++;
                inputBuffer += e.key.toUpperCase();
                
                // Keep only last 10 characters for display
                if (inputBuffer.length > 10) {
                    inputBuffer = inputBuffer.slice(-10);
                }
                
                document.getElementById('inputDisplay').textContent = inputBuffer;
                updateLetterHighlights();
                checkInput();
            }
        });

        // Initialize game
        (async function init() {
            document.getElementById('highScore').textContent = highScore;
            
            // Initialize word pools
            initializeWords();
            
            // Initialize all control words with letter spans
            for (const action in currentWords) {
                const word = currentWords[action];
                const wordElement = document.getElementById(action + 'Word');
                wordElement.innerHTML = word.split('').map(letter => 
                    `<span class="letter unmatched">${letter}</span>`
                ).join('');
            }
            
            // Render game history
            renderHistory();
            
            // Don't create piece or start update loop until game starts
        })();
    </script>
</body>
</html>
