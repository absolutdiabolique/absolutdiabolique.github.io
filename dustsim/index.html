<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DustSim</title>
  <style>
    :root{--ui-w:340px}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    #app{display:flex;height:100vh;overflow:hidden}
    canvas{flex:1;display:block;background:#000}
    #ui{width:var(--ui-w);padding:12px;box-sizing:border-box;background:#0b1220;color:#e6eef8;overflow:auto}
    h1{font-size:18px;margin:0 0 8px}
    label{display:block;margin-top:8px;font-size:13px}
    input,select,button,textarea{width:100%;box-sizing:border-box;margin-top:6px;padding:6px;border-radius:6px;border:1px solid #223; background:#081020;color:inherit}
    pre{white-space:pre-wrap;word-break:break-word}
    .row{display:flex;gap:8px}
    .row> *{flex:1}
    .small{width:70px}
    .controls{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .hint{font-size:12px;color:#9ab}
    footer{font-size:12px;margin-top:12px;color:#789}
  </style>
</head>
<body>
<div id="app">
  <canvas id="c"></canvas>
  <div id="ui">
    <h1>DustSim</h1>

    <label>Simulation parameters</label>
    <div class="row">
      <div>
        <label>G (gravity constant)</label>
        <input id="G" type="number" step="0.0001" value="1000">
      </div>
      <div>
        <label>Time step (dt)</label>
        <input id="dt" type="number" step="0.001" value="0.016">
      </div>
    </div>

    <label>Particles</label>
    <div class="row">
      <div>
        <label>Total Particle Count</label>
        <input id="count" type="number" value="3000">
      </div>
      <div>
        <label>Max accel clamp</label>
        <input id="amax" type="number" value="2000">
      </div>
    </div>

    <label>Starting configuration (JSON)</label>
    <textarea id="json" rows="14">
    {
      "objects": [
        { "type":"star", "x":0, "y":0, "vx":0, "vy":0, "mass":8000, "radius":8 },
        { "type":"disc", "x":0, "y":0, "vx":0.0, "vy":0, "radius":140, "innerRadius":30 }
      ]
    }
    </textarea>

    <div style="margin-top:8px" class="row">
      <button id="apply">Apply JSON</button>
      <button id="reset">Reset View</button>
    </div>

    <label>Quick actions</label>
    <div class="row">
      <button id="pause">Pause</button>
      <button id="step">Step</button>
    </div>

    <label>Info</label>
    <div id="info" style="font-family:monospace;font-size:13px;line-height:1.3"></div>
    <footer>Export this single file to GitHub Pages as index.html</footer>
  </div>
</div>

<script>
// Simple DustSim — single-file
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', {alpha:false});
let W=canvas.width=innerWidth - 340; let H=canvas.height=innerHeight;
window.addEventListener('resize', ()=>{ W=canvas.width=innerWidth - 340; H=canvas.height=innerHeight; });

// UI elements
const Ginp = document.getElementById('G');
const dtInp = document.getElementById('dt');
const cntInp = document.getElementById('count');
const amaxInp = document.getElementById('amax');
const jsonArea = document.getElementById('json');
const applyBtn = document.getElementById('apply');
const resetBtn = document.getElementById('reset');
const pauseBtn = document.getElementById('pause');
const stepBtn = document.getElementById('step');
const infoDiv = document.getElementById('info');

let paused=false; let stepOnce=false;
pauseBtn.addEventListener('click', ()=>{ paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; });
stepBtn.addEventListener('click', ()=>{ stepOnce=true; paused=false; setTimeout(()=>paused=true,50); });
resetBtn.addEventListener('click', ()=>{ view = {x:0,y:0,scale:1}; });

// Data structures
class Star{constructor(x,y,vx,vy,mass,radius){this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.mass=mass;this.radius=radius;}}
class Disc{constructor(x,y,vx,vy,radius,innerRadius){this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.radius=radius;this.innerRadius=innerRadius||0;}}
class Rect{constructor(x,y,vx,vy,w,h){this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.w=w;this.h=h;}}

let stars=[], discs=[], rects=[];
let particles=[]; // {x,y,vx,vy,ax,ay}

function randRange(a,b){return a + Math.random()*(b-a)}
function uniformPointInCircle(r){ // returns [x,y]
  const t = 2*Math.PI*Math.random();
  const u = Math.random()+Math.random();
  let rr = u>1?2-u:u; // approximate sqrt distribution for uniform
  rr *= r;
  return [Math.cos(t)*rr, Math.sin(t)*rr];
}
function uniformPointInAnnulus(r1,r2){
  const t = 2*Math.PI*Math.random();
  // generate radius with probability proportional to r
  const r = Math.sqrt(Math.random()*(r2*r2 - r1*r1) + r1*r1);
  return [Math.cos(t)*r, Math.sin(t)*r];
}
function uniformPointInRect(w,h){
  return [randRange(-w/2,w/2), randRange(-h/2,h/2)];
}// deterministic sunflower pattern for discs and grid for rects
function seedFromConfig(cfg){
  stars=[]; discs=[]; rects=[]; particles=[];
  const obj = cfg.objects || [];
  for(const o of obj){
    if(o.type==='star') stars.push(new Star(+o.x||0,+o.y||0, +o.vx||0, +o.vy||0, +o.mass||1000, +o.radius||6));
    if(o.type==='disc') discs.push(new Disc(+o.x||0,+o.y||0,+o.vx||0,+o.vy||0, +o.radius||100, +o.innerRadius||0));
    if(o.type==='rect') rects.push(new Rect(+o.x||0,+o.y||0,+o.vx||0,+o.vy||0, +o.width||100, +o.height||60));
  }

  // collect regions
  const regions = [];
  for(const d of discs) regions.push({type:'disc',obj:d});
  for(const r of rects) regions.push({type:'rect',obj:r});
  if(regions.length===0){
    discs.push(new Disc(W/2,H/2,0,0, Math.min(W,H)*0.4,0));
    regions.push({type:'disc',obj:discs[discs.length-1]});
  }

  const total = Math.max(1, parseInt(cntInp.value,10)||1000);
  const per = Math.floor(total / regions.length);
  let created = 0;

  const GOLDEN_ANGLE = 2.399963229728653; // radians (~137.5 deg)

  for(let i=0;i<regions.length;i++){
    const rgn = regions[i];
    const n = (i===regions.length-1)? total - created : per;
    const o = rgn.obj;

    if(rgn.type==='disc'){
      // sunflower / Vogel's method -> deterministic circular distribution
      const R = +o.radius;
      const r0 = +o.innerRadius || 0;
      for(let k=0;k<n;k++){
        // fractional index in [0,1)
        const f = (k + 0.5) / n;
        // radial distance — sqrt gives even area spacing
        const radial = Math.sqrt(f);
        const r = r0 + radial * (R - r0);
        const theta = k * GOLDEN_ANGLE;
        const dx = Math.cos(theta) * r;
        const dy = Math.sin(theta) * r;
        particles.push({x: o.x + dx, y: o.y + dy, vx: o.vx, vy: o.vy, ax:0, ay:0});
      }
    }else{
      // grid layout inside rect: deterministic grid placement of n points
      const Wrect = +o.w;
      const Hrect = +o.h;
      // choose grid shape preserving aspect ratio
      const aspect = Math.max(1e-6, Wrect / Hrect);
      let cols = Math.ceil(Math.sqrt(n * aspect));
      let rows = Math.ceil(n / cols);
      // ensure enough cells
      while(cols * (rows-1) >= n) rows--;
      const cellW = Wrect / cols;
      const cellH = Hrect / rows;
      for(let k=0;k<n;k++){
        const col = k % cols;
        const row = Math.floor(k / cols);
        const dx = -Wrect/2 + (col + 0.5) * cellW;
        const dy = -Hrect/2 + (row + 0.5) * cellH;
        particles.push({x: o.x + dx, y: o.y + dy, vx: o.vx, vy: o.vy, ax:0, ay:0});
      }
    }

    created += n;
  }
}


// Physics
function stepPhysics(dt){
  const G = parseFloat(Ginp.value) || 1000;
  const amax = parseFloat(amaxInp.value) || 2000;

  // --- stars mutual gravity (pairwise) ---
  for(let i=0;i<stars.length;i++){
    const si = stars[i];
    let ax=0, ay=0;
    for(let j=0;j<stars.length;j++){
      if(i===j) continue;
      const sj = stars[j];
      const dx = sj.x - si.x; const dy = sj.y - si.y;
      const r2 = dx*dx + dy*dy + 1e-6;
      const r = Math.sqrt(r2);
      const a = G * sj.mass / r2;
      ax += a * dx / r;
      ay += a * dy / r;
    }
    si.vx += ax * dt;
    si.vy += ay * dt;
  }

  // update star positions
  for(const s of stars){ s.x += s.vx * dt; s.y += s.vy * dt; }

  // --- particles acceleration from stars ---
  for(let p of particles){
    let ax=0, ay=0;
    for(const s of stars){
      const dx = s.x - p.x; const dy = s.y - p.y;
      const r2 = dx*dx + dy*dy + 0.0001;
      const r = Math.sqrt(r2);
      const a = G * s.mass / r2;
      ax += a * dx / r;
      ay += a * dy / r;
    }
    // clamp
    const am = Math.sqrt(ax*ax + ay*ay);
    if(am>amax){ ax *= amax/am; ay *= amax/am; }
    p.ax = ax; p.ay = ay;
    // integrate velocity & position (semi-implicit)
    p.vx += p.ax * dt;
    p.vy += p.ay * dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
  }
}

// Color mapping (acceleration magnitude -> hue)
function accelToColor(a, amax){
  // map 0..amax to 240 (blue) -> 0 (red)
  const t = Math.max(0, Math.min(1, a/amax));
  const hue = 240 - 240 * t; // 240 blue to 0 red
  const sat = 100 - 5*t;
  const light = 50 + 10*t;
  return 'hsl('+hue+','+sat+'%,'+light+'%)';
}

let lastTime = performance.now();
let view = {x:0,y:0,scale:1};
let frames=0, accumTime=0;
function render(now){
  const rawdt = (now - lastTime)/1000; lastTime = now;
  const targetDt = parseFloat(dtInp.value) || 0.016;

  if(!paused || stepOnce){
    stepPhysics(targetDt);
    if(stepOnce) { stepOnce=false; paused=true; }
  }

  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,W,H);

  // pixel/world scaling
  const s = W / (1000 * view.scale);   // px per world unit

  // draw particles
  const amax = parseFloat(amaxInp.value)||2000;
  for(const p of particles){
    const ax = p.ax||0, ay = p.ay||0;
    const a = Math.sqrt(ax*ax + ay*ay);
    ctx.fillStyle = accelToColor(a, amax);

    const px = (p.x - view.x) * s + W/2;
    const py = (p.y - view.y) * s + H/2;

    const ix = px|0, iy = py|0;
    if(ix<0 || iy<0 || ix>=W || iy>=H) continue;

    ctx.fillRect(ix, iy, 1, 1);
  }

  // draw stars
  for(const sObj of stars){
    const sx = (sObj.x - view.x) * s + W/2;
    const sy = (sObj.y - view.y) * s + H/2;

    const sr = Math.max(1, sObj.radius * s);

    ctx.beginPath();
    ctx.fillStyle = '#fff';
    ctx.globalAlpha = 0.9;
    ctx.arc(sx, sy, sr, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1.0;

    // mass ring scaled
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;
    ctx.arc(sx, sy, sObj.radius * 4 * s, 0, Math.PI*2);
    ctx.stroke();
  }

  // draw discs
  ctx.strokeStyle = 'rgba(120,180,255,0.12)';
  ctx.lineWidth = 1;

  for(const d of discs){
    const dx = (d.x - view.x) * s + W/2;
    const dy = (d.y - view.y) * s + H/2;

    ctx.beginPath();
    ctx.arc(dx, dy, d.radius * s, 0, Math.PI*2);
    ctx.stroke();

    if(d.innerRadius > 0){
      ctx.beginPath();
      ctx.arc(dx, dy, d.innerRadius * s, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  // draw rects
  for(const r of rects){
    const cx = (r.x - view.x) * s + W/2;
    const cy = (r.y - view.y) * s + H/2;

    const wScaled = r.w * s;
    const hScaled = r.h * s;

    ctx.beginPath();
    ctx.rect(cx - wScaled/2, cy - hScaled/2, wScaled, hScaled);
    ctx.stroke();
  }

  // info
  frames++; accumTime += rawdt;
  if(accumTime>0.5){
    infoDiv.textContent =
      `particles: ${particles.length}\nstars: ${stars.length}  dt: ${targetDt}  G: ${Ginp.value}`;
    frames=0; accumTime=0;
  }

  requestAnimationFrame(render);
}

// UI: parse JSON and seed
applyBtn.addEventListener('click', ()=>{
  let cfg;
  try{ cfg = JSON.parse(jsonArea.value); }catch(e){ alert('JSON parse error: '+e.message); return; }
  seedFromConfig(cfg);
});

// initial seed
try{ seedFromConfig(JSON.parse(jsonArea.value)); }catch(e){ console.error('invalid initial JSON',e); }

requestAnimationFrame(render);

// Optional: basic mouse pan & zoom
let dragging=false, lastMouse=null;
canvas.addEventListener('mousedown',(e)=>{
  dragging=true; lastMouse=[e.clientX,e.clientY]; 
});
window.addEventListener('mouseup',()=>{
  dragging=false; lastMouse=null;
});
window.addEventListener('mousemove',(e)=>{
  if(!dragging) return; const dx = e.clientX - lastMouse[0]; const dy = e.clientY - lastMouse[1]; view.x -= dx; view.y -= dy; lastMouse=[e.clientX,e.clientY];
});
canvas.addEventListener('wheel',(e)=>{
  e.preventDefault(); const s = Math.exp(-e.deltaY*0.001);
  view.scale *= s;
});

</script>
</body>
</html>
