<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DustSim — GitHub Pages</title>
  <style>
    :root{--ui-w:340px}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    #app{display:flex;height:100vh;overflow:hidden}
    canvas{flex:1;display:block;background:#000}
    #ui{width:var(--ui-w);padding:12px;box-sizing:border-box;background:#0b1220;color:#e6eef8;overflow:auto}
    h1{font-size:18px;margin:0 0 8px}
    label{display:block;margin-top:8px;font-size:13px}
    input,select,button,textarea{width:100%;box-sizing:border-box;margin-top:6px;padding:6px;border-radius:6px;border:1px solid #223; background:#081020;color:inherit}
    pre{white-space:pre-wrap;word-break:break-word}
    .row{display:flex;gap:8px}
    .row> *{flex:1}
    .small{width:70px}
    .controls{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .hint{font-size:12px;color:#9ab}
    footer{font-size:12px;margin-top:12px;color:#789}
  </style>
</head>
<body>
<div id="app">
  <canvas id="c"></canvas>
  <div id="ui">
    <h1>DustSim (GitHub Pages)</h1>
    <div class="hint">Dust colored by acceleration magnitude. Load or edit JSON then press "Apply".</div>

    <label>Simulation parameters</label>
    <div class="row">
      <div>
        <label>G (gravity constant)</label>
        <input id="G" type="number" step="0.0001" value="1000">
      </div>
      <div>
        <label>Time step (dt)</label>
        <input id="dt" type="number" step="0.001" value="0.016">
      </div>
    </div>

    <label>Particles</label>
    <div class="row">
      <div>
        <label>Count</label>
        <input id="count" type="number" value="3000">
      </div>
      <div>
        <label>Max accel clamp</label>
        <input id="amax" type="number" value="2000">
      </div>
    </div>

    <label>Starting configuration (JSON)</label>
    <textarea id="json" rows="14">
    {
      "objects": [
        { "type":"star", "x":0, "y":0, "vx":0, "vy":0, "mass":8000, "radius":8 },
        { "type":"disc", "x":0, "y":0, "vx":0.0, "vy":0, "radius":140, "innerRadius":30 }
      ]
    }
    </textarea>

    <div style="margin-top:8px" class="row">
      <button id="apply">Apply JSON</button>
      <button id="reset">Reset View</button>
    </div>

    <label>Quick actions</label>
    <div class="row">
      <button id="pause">Pause</button>
      <button id="step">Step</button>
    </div>

    <label>Info</label>
    <div id="info" style="font-family:monospace;font-size:13px;line-height:1.3"></div>
    <footer>Export this single file to GitHub Pages as index.html</footer>
  </div>
</div>

<script>
// Simple DustSim — single-file
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', {alpha:false});
let W=canvas.width=innerWidth - 340; let H=canvas.height=innerHeight;
window.addEventListener('resize', ()=>{ W=canvas.width=innerWidth - 340; H=canvas.height=innerHeight; });

// UI elements
const Ginp = document.getElementById('G');
const dtInp = document.getElementById('dt');
const cntInp = document.getElementById('count');
const amaxInp = document.getElementById('amax');
const jsonArea = document.getElementById('json');
const applyBtn = document.getElementById('apply');
const resetBtn = document.getElementById('reset');
const pauseBtn = document.getElementById('pause');
const stepBtn = document.getElementById('step');
const infoDiv = document.getElementById('info');

let paused=false; let stepOnce=false;
pauseBtn.addEventListener('click', ()=>{ paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; });
stepBtn.addEventListener('click', ()=>{ stepOnce=true; paused=false; setTimeout(()=>paused=true,50); });
resetBtn.addEventListener('click', ()=>{ view = {x:0,y:0,scale:1}; });

// Data structures
class Star{constructor(x,y,vx,vy,mass,radius){this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.mass=mass;this.radius=radius;}}
class Disc{constructor(x,y,vx,vy,radius,innerRadius){this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.radius=radius;this.innerRadius=innerRadius||0;}}
class Rect{constructor(x,y,vx,vy,w,h){this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.w=w;this.h=h;}}

let stars=[], discs=[], rects=[];
let particles=[]; // {x,y,vx,vy,ax,ay}

function randRange(a,b){return a + Math.random()*(b-a)}
function uniformPointInCircle(r){ // returns [x,y]
  const t = 2*Math.PI*Math.random();
  const u = Math.random()+Math.random();
  let rr = u>1?2-u:u; // approximate sqrt distribution for uniform
  rr *= r;
  return [Math.cos(t)*rr, Math.sin(t)*rr];
}
function uniformPointInAnnulus(r1,r2){
  const t = 2*Math.PI*Math.random();
  // generate radius with probability proportional to r
  const r = Math.sqrt(Math.random()*(r2*r2 - r1*r1) + r1*r1);
  return [Math.cos(t)*r, Math.sin(t)*r];
}
function uniformPointInRect(w,h){
  return [randRange(-w/2,w/2), randRange(-h/2,h/2)];
}

function seedFromConfig(cfg){
  stars=[]; discs=[]; rects=[]; particles=[];
  const obj = cfg.objects || [];
  for(const o of obj){
    if(o.type==='star') stars.push(new Star(+o.x||0,+o.y||0, +o.vx||0, +o.vy||0, +o.mass||1000, +o.radius||6));
    if(o.type==='disc') discs.push(new Disc(+o.x||0,+o.y||0,+o.vx||0,+o.vy||0, +o.radius||100, +o.innerRadius||0));
    if(o.type==='rect') rects.push(new Rect(+o.x||0,+o.y||0,+o.vx||0,+o.vy||0, +o.width||100, +o.height||60));
  }

  // distribute particles equally among regions
  const regions = [];
  for(const d of discs) regions.push({type:'disc',obj:d});
  for(const r of rects) regions.push({type:'rect',obj:r});
  // if no regions provided, create a big fallback
  if(regions.length===0){
    discs.push(new Disc(W/2,H/2,0,0, Math.min(W,H)*0.4,0));
    regions.push({type:'disc',obj:discs[discs.length-1]});
  }

  const total = Math.max(1, parseInt(cntInp.value,10)||1000);
  const per = Math.floor(total / regions.length);
  let created = 0;
  for(let i=0;i<regions.length;i++){
    const r = regions[i];
    const n = (i===regions.length-1)? total - created : per;
    const o = r.obj;
    if(r.type==='disc'){
      for(let k=0;k<n;k++){
        const [dx,dy] = o.innerRadius>0 ? uniformPointInAnnulus(o.innerRadius,o.radius) : uniformPointInCircle(o.radius);
        particles.push({x:o.x+dx,y:o.y+dy,vx:o.vx,vy:o.vy,ax:0,ay:0});
      }
    }else{
      for(let k=0;k<n;k++){
        const [dx,dy] = uniformPointInRect(o.w,o.h);
        particles.push({x:o.x+dx,y:o.y+dy,vx:o.vx,vy:o.vy,ax:0,ay:0});
      }
    }
    created += n;
  }

}

// Physics
function stepPhysics(dt){
  const G = parseFloat(Ginp.value) || 1000;
  const amax = parseFloat(amaxInp.value) || 2000;

  // --- stars mutual gravity (pairwise) ---
  for(let i=0;i<stars.length;i++){
    const si = stars[i];
    let ax=0, ay=0;
    for(let j=0;j<stars.length;j++){
      if(i===j) continue;
      const sj = stars[j];
      const dx = sj.x - si.x; const dy = sj.y - si.y;
      const r2 = dx*dx + dy*dy + 1e-6;
      const r = Math.sqrt(r2);
      const a = G * sj.mass / r2;
      ax += a * dx / r;
      ay += a * dy / r;
    }
    si.vx += ax * dt;
    si.vy += ay * dt;
  }

  // update star positions
  for(const s of stars){ s.x += s.vx * dt; s.y += s.vy * dt; }

  // --- particles acceleration from stars ---
  for(let p of particles){
    let ax=0, ay=0;
    for(const s of stars){
      const dx = s.x - p.x; const dy = s.y - p.y;
      const r2 = dx*dx + dy*dy + 0.0001;
      const r = Math.sqrt(r2);
      const a = G * s.mass / r2;
      ax += a * dx / r;
      ay += a * dy / r;
    }
    // clamp
    const am = Math.sqrt(ax*ax + ay*ay);
    if(am>amax){ ax *= amax/am; ay *= amax/am; }
    p.ax = ax; p.ay = ay;
    // integrate velocity & position (semi-implicit)
    p.vx += p.ax * dt;
    p.vy += p.ay * dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
  }
}

// Color mapping (acceleration magnitude -> hue)
function accelToColor(a, amax){
  // map 0..amax to 240 (blue) -> 0 (red)
  const t = Math.max(0, Math.min(1, a/amax));
  const hue = 240 - 240 * t; // 240 blue to 0 red
  const sat = 100 - 5*t;
  const light = 50 + 10*t;
  return 'hsl('+hue+','+sat+'%,'+light+'%)';
}

let lastTime = performance.now();
let view = {x:0,y:0,scale:1};
let frames=0, accumTime=0;
function render(now){
  const rawdt = (now - lastTime)/1000; lastTime = now;
  const targetDt = parseFloat(dtInp.value) || 0.016;

  if(!paused || stepOnce){
    stepPhysics(targetDt);
    if(stepOnce) { stepOnce=false; paused=true; }
  }

  // draw
  ctx.clearRect(0,0,W,H);

  // draw particles as tiny rects or pixels
  const image = ctx.createImageData(W,H);
  // fill with black
  // We'll draw particles directly as circles for better color variation
  ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);

  // draw particles
  const amax = parseFloat(amaxInp.value)||2000;
  for(const p of particles){
    const ax = p.ax||0, ay = p.ay||0;
    const a = Math.sqrt(ax*ax + ay*ay);
    ctx.fillStyle = accelToColor(a, amax);
    // draw 1px (use fillRect to be fast)
    const px = Math.round(p.x - view.x);
    const py = Math.round(p.y - view.y);
    if(px<0 || py<0 || px>=W || py>=H) continue;
    ctx.fillRect(px,py,1,1);
  }

  // draw stars
  for(const s of stars){
    const sx = s.x - view.x, sy = s.y - view.y;
    ctx.beginPath(); ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.9; ctx.arc(sx,sy, Math.max(1,s.radius), 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0;
    // mass ring
    ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1; ctx.arc(sx,sy,s.radius*4,0,Math.PI*2); ctx.stroke();
  }

  // draw regions outlines
  ctx.strokeStyle = 'rgba(120,180,255,0.12)'; ctx.lineWidth=1;
  for(const d of discs){ ctx.beginPath(); ctx.arc(d.x-view.x,d.y-view.y,d.radius,0,Math.PI*2); ctx.stroke(); if(d.innerRadius>0){ ctx.beginPath(); ctx.arc(d.x-view.x,d.y-view.y,d.innerRadius,0,Math.PI*2); ctx.stroke(); } }
  for(const r of rects){ ctx.beginPath(); ctx.rect(r.x - r.w/2 - view.x, r.y - r.h/2 - view.y, r.w, r.h); ctx.stroke(); }

  // info
  frames++; accumTime += rawdt;
  if(accumTime>0.5){ infoDiv.textContent = `particles: ${particles.length}\nstars: ${stars.length}  dt: ${targetDt}  G: ${Ginp.value}`; frames=0; accumTime=0; }

  requestAnimationFrame(render);
}

// UI: parse JSON and seed
applyBtn.addEventListener('click', ()=>{
  let cfg;
  try{ cfg = JSON.parse(jsonArea.value); }catch(e){ alert('JSON parse error: '+e.message); return; }
  seedFromConfig(cfg);
});

// initial seed
try{ seedFromConfig(JSON.parse(jsonArea.value)); }catch(e){ console.error('invalid initial JSON',e); }

requestAnimationFrame(render);

// Optional: basic mouse pan & zoom
let dragging=false, lastMouse=null;
canvas.addEventListener('mousedown',(e)=>{ dragging=true; lastMouse=[e.clientX,e.clientY]; });
window.addEventListener('mouseup',()=>{ dragging=false; lastMouse=null; });
window.addEventListener('mousemove',(e)=>{ if(!dragging) return; const dx = e.clientX - lastMouse[0]; const dy = e.clientY - lastMouse[1]; view.x -= dx; view.y -= dy; lastMouse=[e.clientX,e.clientY]; });
canvas.addEventListener('wheel',(e)=>{ e.preventDefault(); const s = Math.exp(-e.deltaY*0.001); view.scale *= s; /*not used*/ });

</script>
</body>
</html>
