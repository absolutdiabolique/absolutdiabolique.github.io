<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BounceSim</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>
<div id="app">
  <canvas id="c"></canvas>

  <div id="ui">
    <h2 style="margin:0 0 6px 0">BounceSim (CCD + hybrid)</h2>

    <label>Simulation parameters</label>
    <div class="row">
      <div><label>Gravity</label><input id="G" type="number" step="1" value="900"></div>
      <div><label>dt (s)</label><input id="dt" type="number" step="0.001" value="0.016"></div>
    </div>

    <label>Dust</label>
    <div class="row">
      <div><label>Density</label><input id="density" type="number" step="0.01" value="0.35"></div>
      <div><label>Particle radius</label><input id="prad" type="number" step="0.2" value="2"></div>
    </div>

    <label>JSON objects</label>
    <textarea id="json" rows="16">
{
  "objects": [
    { "type":"line", "x1":-220, "y1":100, "x2":220, "y2":120, "elasticity":0.6 },
    { "type":"ellipse", "x":180, "y":320, "rx":100, "ry":60, "elasticity":0.4 },
    { "type":"rectCloud", "x":-240, "y":-120, "w":260, "h":80, "elasticity":0.35 },
    { "type":"discCloud", "x":60, "y":-220, "radius":120, "innerRadius":20, "elasticity":0.3 }
  ]
}
    </textarea>

    <div class="row" style="margin-top:8px">
      <button id="apply">Apply JSON</button>
      <button id="reset">Reset View</button>
    </div>

    <label>Quick</label>
    <div class="row">
      <button id="pause">Pause</button>
      <button id="step">Step</button>
    </div>

    <label>Debug</label>
    <div class="row">
      <div><label>Max sub-steps</label><input id="maxSteps" type="number" step="1" value="5"></div>
      <div><label>CCD samples (ellipse/line)</label><input id="ccdSamples" type="number" step="1" value="12"></div>
    </div>

    <label>Info</label>
    <div id="info"></div>
  </div>
</div>

<script>
// ---------------------------
// Canvas + UI
// ---------------------------
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false });
let W = canvas.width = innerWidth - 340, H = canvas.height = innerHeight;
window.addEventListener('resize', ()=>{ W = canvas.width = innerWidth - 340; H = canvas.height = innerHeight; });

const Ginp = document.getElementById('G');
const dtInp = document.getElementById('dt');
const densityInp = document.getElementById('density');
const pradInp = document.getElementById('prad');
const jsonArea = document.getElementById('json');
const applyBtn = document.getElementById('apply');
const resetBtn = document.getElementById('reset');
const pauseBtn = document.getElementById('pause');
const stepBtn = document.getElementById('step');
const infoDiv = document.getElementById('info');
const maxStepsInp = document.getElementById('maxSteps');
const ccdSamplesInp = document.getElementById('ccdSamples');

let paused = false, stepOnce = false;
pauseBtn.addEventListener('click', ()=>{ paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; });
stepBtn.addEventListener('click', ()=>{ stepOnce=true; paused=false; setTimeout(()=>paused=true,50); });
resetBtn.addEventListener('click', ()=>{ view = {x:0,y:0,scale:1}; });

// ---------------------------
// Data structures
// ---------------------------
class Line{constructor(x1,y1,x2,y2,e){this.x1=x1;this.y1=y1;this.x2=x2;this.y2=y2;this.e=e||0.3}}
class Ellipse{constructor(x,y,rx,ry,e){this.x=x;this.y=y;this.rx=rx;this.ry=ry;this.e=e||0.3}}
class RectCloud{constructor(x,y,w,h,e){this.x=x;this.y=y;this.w=w;this.h=h;this.e=e||0.3}}
class DiscCloud{constructor(x,y,r,inner,e){this.x=x;this.y=y;this.r=r;this.inner=inner||0;this.e=e||0.3}}

let lines=[], ellipses=[], rects=[], discs=[];
let particles=[];

// ---------------------------
// Math helpers
// ---------------------------
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function dot(ax,ay,bx,by){return ax*bx+ay*by}
function length(ax,ay){return Math.hypot(ax,ay)}
function normalize(ax,ay){ const L=Math.hypot(ax,ay)||1; return [ax/L, ay/L]; }
function addV(a,b){return {x:a.x+b.x,y:a.y+b.y}}
function mulV(a,s){return {x:a.x*s,y:a.y*s}}
function subV(a,b){return {x:a.x-b.x,y:a.y-b.y}}

// point-segment distance & closest point
function closestPointOnSegment(px,py, ax,ay, bx,by){
  const vx = bx-ax, vy = by-ay;
  const wx = px-ax, wy = py-ay;
  const vlen2 = vx*vx + vy*vy;
  if(vlen2===0) return {x:ax,y:ay,t:0};
  let t = (wx*vx + wy*vy)/vlen2;
  t = clamp(t,0,1);
  return {x: ax + vx*t, y: ay + vy*t, t};
}

// ---------------------------
// Seeding (sunflower + grid)
// ---------------------------
function seedFromConfig(cfg){
  lines=[]; ellipses=[]; rects=[]; discs=[]; particles=[];
  const objs = cfg.objects || [];

  for(const o of objs){
    if(o.type==='line') lines.push(new Line(+o.x1||0,+o.y1||0,+o.x2||0,+o.y2||0,+o.elasticity||0.3));
    if(o.type==='ellipse') ellipses.push(new Ellipse(+o.x||0,+o.y||0,+o.rx||50,+o.ry||30,+o.elasticity||0.3));
    if(o.type==='rectCloud') rects.push(new RectCloud(+o.x||0,+o.y||0,+o.w||200,+o.h||60,+o.elasticity||0.3));
    if(o.type==='discCloud') discs.push(new DiscCloud(+o.x||0,+o.y||0,+o.radius||100,+o.innerRadius||0,+o.elasticity||0.3));
  }

  // default: if nothing provided, add a big rect cloud in center
  if(discs.length===0 && rects.length===0 && lines.length===0 && ellipses.length===0){
    discs.push(new DiscCloud(0, -150, Math.min(W,H)*0.25, 0, 0.3));
  }

  const density = Math.max(0, parseFloat(densityInp.value)||0.3);
  const GOLDEN = 2.3999632297;

  for(const d of discs){
    const area = Math.PI*(d.r*d.r - (d.inner||0)*(d.inner||0));
    const n = Math.max(1, Math.floor(area * density / 100)); // scale down to keep particles reasonable
    for(let k=0;k<n;k++){
      const f=(k+0.5)/n; const r = Math.sqrt(f)*(d.r-d.inner) + d.inner;
      const th = k*GOLDEN;
      particles.push({ x:d.x + Math.cos(th)*r, y:d.y + Math.sin(th)*r, vx:0, vy:0, elasticity:d.e });
    }
  }

  for(const r of rects){
    const area = r.w*r.h;
    const n = Math.max(1, Math.floor(area * density / 400));
    const cols = Math.ceil(Math.sqrt(n * (r.w/r.h)));
    const rows = Math.ceil(n / cols);
    const cellW = r.w/cols, cellH=r.h/rows;
    for(let k=0;k<n;k++){
      const col=k%cols, row=Math.floor(k/cols);
      particles.push({
        x: r.x + (-r.w/2 + (col+0.5)*cellW),
        y: r.y + (-r.h/2 + (row+0.5)*cellH),
        vx:0, vy:0, elasticity: r.e
      });
    }
  }

  infoDiv.textContent = `seeded ${particles.length} particles`;
}

// ---------------------------
// CCD utilities
// - AABB sweep with radius expansion (exact in slab sense)
// - hybrid sampling for segment/ellipse (sufficiently accurate if samples high)
// ---------------------------
function expandAABB(boxMinX,boxMinY, boxMaxX,boxMaxY, r){
  return { minX: boxMinX - r, minY: boxMinY - r, maxX: boxMaxX + r, maxY: boxMaxY + r };
}

// point moving along p0 -> p1, check slab entry time [0,1] against expanded aabb
function sweepAABB_t(p0x,p0y, vx,vy, box){
  const EPS = 1e-9;
  let tmin = 0, tmax = 1;
  let normal = {x:0,y:0};

  // X
  if(Math.abs(vx) < EPS){
    if(p0x < box.minX || p0x > box.maxX) return null;
  } else {
    const inv = 1 / vx;
    let t1 = (box.minX - p0x) * inv;
    let t2 = (box.maxX - p0x) * inv;
    const enter = Math.min(t1,t2), exit = Math.max(t1,t2);
    if(enter > tmin){
      tmin = enter;
      normal = { x: t1 > t2 ? 1 : -1, y:0 };
    }
    tmax = Math.min(tmax, exit);
    if(tmin > tmax) return null;
  }

  // Y
  if(Math.abs(vy) < EPS){
    if(p0y < box.minY || p0y > box.maxY) return null;
  } else {
    const inv = 1 / vy;
    let t1 = (box.minY - p0y) * inv;
    let t2 = (box.maxY - p0y) * inv;
    const enter = Math.min(t1,t2), exit = Math.max(t1,t2);
    if(enter > tmin){
      tmin = enter;
      normal = { x:0, y: t1 > t2 ? 1 : -1 };
    }
    tmax = Math.min(tmax, exit);
    if(tmin > tmax) return null;
  }

  if(tmin < 0 || tmin > 1) return null;
  return { t: tmin, normal };
}

// numeric sample-based sweep for segment & ellipse
// returns earliest hit {t, normal, kind, obj} or null
function sampleSweepForSegmentOrEllipse(p0x,p0y, dx,dy, radius, samples){
  // samples: number of sample points to check along the path (will find intervals of penetration then binary refine)
  const hits = [];
  let prevInside = false;
  let prevD = null;
  let prevT = 0;

  function checkAt(t){
    const x = p0x + dx*t, y = p0y + dy*t;
    // check lines
    for(const L of lines){
      const c = closestPointOnSegment(x,y, L.x1, L.y1, L.x2, L.y2);
      const dist = Math.hypot(x - c.x, y - c.y);
      if(dist <= radius + 1e-6) return {kind:'line', obj:L, cx:c.x, cy:c.y, dist, t};
    }
    // check ellipses
    for(const E of ellipses){
      const rx=E.rx, ry=E.ry;
      const nx = (x - E.x)/rx, ny = (y - E.y)/ry;
      const k = nx*nx + ny*ny;
      if(k <= 1 + 1e-9) return {kind:'ellipse', obj:E, k, t, x, y};
    }
    return null;
  }

  const N = Math.max(3, samples||12);
  let lastHit = null;
  // coarse scan to find first interval where penetration occurs
  for(let i=0;i<=N;i++){
    const t = i/N;
    const r = checkAt(t);
    if(r && lastHit===null){
      // found first sample inside -> binary refine on [prevT, t]
      let a = Math.max(0, (i-1)/N), b = t;
      for(let iter=0; iter<12; iter++){
        const m=(a+b)/2;
        const rm = checkAt(m);
        if(rm) b = m; else a = m;
      }
      const tt = b;
      const refined = checkAt(tt);
      return refined ? { t: tt, ...refined } : null;
    }
  }
  return null;
}

// ---------------------------
// Single particle movement with hybrid CCD
// - tries exact slab CCD against AABBs (rect obstacles and screen bounds) using expanded AABB
// - uses sample-based CCD for lines and ellipses (coarse sample + binary refine)
// - if multiple contacts: choose earliest t, move to contact, reflect using elasticity, continue with remaining fraction
// - limit iterations per particle to avoid stalling
// ---------------------------
function moveParticleHybrid(p, dt){
  const G = parseFloat(Ginp.value)||900;
  const radius = parseFloat(pradInp.value)||2;
  const maxIter = Math.max(1, parseInt(maxStepsInp.value)||4);
  const samples = Math.max(6, parseInt(ccdSamplesInp.value)||12);

  // integrate velocity (semi-implicit)
  p.vy += G * dt;
  const totalDx = p.vx * dt;
  const totalDy = p.vy * dt;

  let remainingX = totalDx, remainingY = totalDy;
  let remainingFraction = 1;

  for(let iter=0; iter<maxIter; iter++){
    if(Math.hypot(remainingX, remainingY) < 1e-6) break;

    // find earliest collision among:
    // - rects (AABB) (use sweepAABB_t with expanded rect)
    // - bounding screen edges (as AABB)
    // - lines & ellipses (sample based)

    let earliest = 1.0;
    let hitNormal = null;
    let hitObj = null;
    let hitKind = null;

    // AABB rectangles (rects)
    for(const R of rects){
      const minX = R.x - R.w/2, minY = R.y - R.h/2;
      const maxX = R.x + R.w/2, maxY = R.y + R.h/2;
      const expanded = expandAABB(minX,minY, maxX,maxY, radius);
      const res = sweepAABB_t(p.x, p.y, remainingX, remainingY, expanded);
      if(res && res.t < earliest){
        earliest = res.t;
        hitNormal = res.normal;
        hitObj = R; hitKind='rect';
      }
    }

    // Screen bounds as AABB (prevent leaving)
    const screenBox = expandAABB(-W/2 + view.x, -H/2 + view.y, W/2 + view.x, H/2 + view.y, radius);
    const resScreen = sweepAABB_t(p.x, p.y, remainingX, remainingY, screenBox);
    if(resScreen && resScreen.t < earliest){
      earliest = resScreen.t;
      hitNormal = resScreen.normal;
      hitObj = null; hitKind='screen';
    }

    // sample-based sweep for lines & ellipses
    const sampHit = sampleSweepForSegmentOrEllipse(p.x, p.y, remainingX, remainingY, radius, samples);
    if(sampHit && sampHit.t < earliest){
      earliest = sampHit.t;
      if(sampHit.kind === 'line'){
        // compute normal from segment closest point
        const L = sampHit.obj;
        const cp = closestPointOnSegment(p.x + remainingX*earliest, p.y + remainingY*earliest, L.x1, L.y1, L.x2, L.y2);
        const nx = (p.x + remainingX*earliest - cp.x);
        const ny = (p.y + remainingY*earliest - cp.y);
        const nlen = Math.hypot(nx,ny) || 1;
        hitNormal = { x: nx/nlen, y: ny/nlen };
        hitObj = L; hitKind='line';
      } else if(sampHit.kind === 'ellipse'){
        // approximate normal for ellipse at contact: gradient of implicit function
        const E = sampHit.obj;
        const cx = p.x + remainingX*earliest, cy = p.y + remainingY*earliest;
        const nx = (cx - E.x)/(E.rx*E.rx);
        const ny = (cy - E.y)/(E.ry*E.ry);
        const nlen = Math.hypot(nx,ny) || 1;
        hitNormal = { x: nx/nlen, y: ny/nlen };
        hitObj = E; hitKind='ellipse';
      }
    }

    if(!hitNormal){
      // no collision in remaining motion: finish move
      p.x += remainingX;
      p.y += remainingY;
      break;
    }

    // clamp earliest into [0,1]
    earliest = clamp(earliest, 0, 1);

    // move to contact (slightly back off by eps to avoid re-penetration)
    const eps = 1e-4;
    const moveX = remainingX * earliest;
    const moveY = remainingY * earliest;
    p.x += moveX;
    p.y += moveY;

    // reflect velocity around normal with elasticity = particle.elasticity * object.elasticity (if any)
    let objE = 1.0;
    if(hitKind==='line' || hitKind==='ellipse') objE = hitObj.e || 1.0;
    if(hitKind==='rect') objE = hitObj.e || 1.0;
    if(hitKind==='screen') objE = 0.2;

    const e = clamp((p.elasticity !== undefined ? p.elasticity : 0.5) * objE, 0, 1);

    // compute vel before reflection (we must use current velocities)
    // reflect velocity vector across normal
    const vn = dot(p.vx, p.vy, hitNormal.x, hitNormal.y);
    if(vn < 0){
      // reflect and apply elasticity
      p.vx = p.vx - (1 + e) * vn * hitNormal.x;
      p.vy = p.vy - (1 + e) * vn * hitNormal.y;
    }

    // small positional nudge along normal to avoid sticking
    p.x += hitNormal.x * eps;
    p.y += hitNormal.y * eps;

    // remaining motion after impact
    const leftoverFrac = 1 - earliest;
    remainingX = remainingX * leftoverFrac;
    remainingY = remainingY * leftoverFrac;

    // remove component along normal from leftover (slide)
    const proj = dot(remainingX, remainingY, hitNormal.x, hitNormal.y);
    remainingX = remainingX - proj * hitNormal.x;
    remainingY = remainingY - proj * hitNormal.y;

    // continue iterating with reduced remaining
  }
}

// ---------------------------
// Rendering and main loop
// ---------------------------
let lastTime = performance.now();
let view = { x:0, y:0, scale:1 };
let fps=0, fpsAccum=0, fpsFrames=0;

function render(now){
  const rawdt = (now - lastTime) / 1000;
  lastTime = now;

  // fps
  fpsFrames++; fpsAccum += rawdt;
  if(fpsAccum >= 0.25){ fps = fpsFrames / fpsAccum; fpsFrames=0; fpsAccum=0; }

  const targetDt = parseFloat(dtInp.value) || 0.016;

  if(!paused || stepOnce){
    // step
    // move each particle with hybrid CCD
    for(const p of particles){
      moveParticleHybrid(p, targetDt);
    }
    if(stepOnce){ stepOnce=false; paused=true; }
  }

  // draw
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#001';
  ctx.fillRect(0,0,W,H);

  const s = W/(1000 * view.scale);

  // particles
  const prad = parseFloat(pradInp.value) || 2;
  for(const p of particles){
    const px = (p.x - view.x) * s + W/2;
    const py = (p.y - view.y) * s + H/2;
    ctx.fillStyle = 'white';
    ctx.fillRect(px|0, py|0, Math.max(1,prad*s|0), Math.max(1,prad*s|0));
  }

  // draw lines
  ctx.strokeStyle = 'rgba(200,200,255,0.25)';
  ctx.lineWidth = 1;
  for(const L of lines){
    ctx.beginPath();
    ctx.moveTo((L.x1-view.x)*s + W/2, (L.y1-view.y)*s + H/2);
    ctx.lineTo((L.x2-view.x)*s + W/2, (L.y2-view.y)*s + H/2);
    ctx.stroke();
  }

  // draw rect outlines
  ctx.strokeStyle = 'rgba(120,255,180,0.14)';
  for(const R of rects){
    const cx = (R.x - view.x)*s + W/2, cy = (R.y - view.y)*s + H/2;
    const w = R.w * s, h = R.h * s;
    ctx.strokeRect(cx - w/2, cy - h/2, w, h);
  }

  // draw ellipses
  ctx.strokeStyle = 'rgba(255,190,120,0.12)';
  for(const E of ellipses){
    ctx.beginPath();
    ctx.ellipse((E.x-view.x)*s + W/2, (E.y-view.y)*s + H/2, E.rx*s, E.ry*s, 0, 0, Math.PI*2);
    ctx.stroke();
  }

  // HUD
  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.fillStyle='white';
  ctx.font='13px monospace';
  ctx.fillText(`particles: ${particles.length}  FPS: ${fps.toFixed(1)}`, 8, 8);
  ctx.restore();

  // info panel
  infoDiv.textContent = `particles: ${particles.length}\nlines: ${lines.length}  ellipses: ${ellipses.length}  rectClouds: ${rects.length}  discClouds: ${discs.length}\nmaxSteps:${maxStepsInp.value}  ccdSamples:${ccdSamplesInp.value}`;

  requestAnimationFrame(render);
}

// ---------------------------
// Input handlers + pan/zoom
// ---------------------------
applyBtn.addEventListener('click', ()=>{
  try{ seedFromConfig(JSON.parse(jsonArea.value)); } catch(e){ alert('JSON parse error: '+e.message); }
});
try{ seedFromConfig(JSON.parse(jsonArea.value)); } catch(e){ console.error('seed parse', e); }

let dragging=false, lastMouse=null;
canvas.addEventListener('mousedown',(e)=>{ dragging=true; lastMouse=[e.clientX,e.clientY]; });
window.addEventListener('mouseup',()=>{ dragging=false; lastMouse=null; });
window.addEventListener('mousemove',(e)=>{ if(!dragging) return; const dx=e.clientX-lastMouse[0], dy=e.clientY-lastMouse[1]; view.x -= dx; view.y -= dy; lastMouse=[e.clientX,e.clientY]; });
canvas.addEventListener('wheel',(e)=>{ e.preventDefault(); const sc=Math.exp(-e.deltaY*0.001); view.scale *= sc; });

// ---------------------------
// Start
// ---------------------------
requestAnimationFrame(render);
</script>
</body>
</html>
