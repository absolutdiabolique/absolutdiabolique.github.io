<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Material Graph</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1625 0%, #221c30 100%);
            color: #e8e3f0;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: grid;
            grid-template-columns: 280px 1fr 400px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            gap: 0;
            position: relative;
        }

        .resize-handle {
            position: absolute;
            background: rgba(139, 92, 246, 0.1);
            z-index: 10;
            transition: background 0.2s;
        }

        .resize-handle:hover {
            background: rgba(139, 92, 246, 0.3);
        }

        .resize-handle.vertical {
            width: 4px;
            top: 60px;
            bottom: 0;
            cursor: col-resize;
        }

        .resize-handle.left {
            left: 280px;
        }

        .resize-handle.right {
            right: 400px;
        }

        .resize-handle.horizontal {
            height: 4px;
            left: 0;
            right: 0;
            cursor: row-resize;
        }

        .header {
            grid-column: 1 / -1;
            background: rgba(30, 25, 40, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(139, 92, 246, 0.2);
            padding: 0 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .logo {
            font-size: 20px;
            font-weight: 600;
            background: linear-gradient(135deg, #a78bfa 0%, #818cf8 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .hint-text {
            font-size: 13px;
            color: #9ca3af;
            margin-right: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .hint-icon {
            font-size: 18px;
        }

        .btn {
            padding: 8px 16px;
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 8px;
            color: #c4b5fd;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .btn:hover {
            background: rgba(139, 92, 246, 0.25);
            border-color: rgba(139, 92, 246, 0.5);
        }

        .btn.primary {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            border-color: #8b5cf6;
            color: white;
        }

        .btn.primary:hover {
            background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
        }

        .node-palette {
            background: rgba(25, 20, 35, 0.6);
            border-right: 1px solid rgba(139, 92, 246, 0.2);
            padding: 20px;
            overflow-y: auto;
        }

        .palette-section {
            margin-bottom: 24px;
        }

        .palette-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #9ca3af;
            margin-bottom: 12px;
            font-weight: 600;
        }

        .node-item {
            padding: 12px;
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: move;
            transition: all 0.2s;
            font-size: 13px;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .node-item:hover {
            background: rgba(139, 92, 246, 0.2);
            border-color: rgba(139, 92, 246, 0.4);
            transform: translateX(4px);
        }

        .node-item-desc {
            font-size: 11px;
            color: #9ca3af;
            margin-top: 4px;
        }

        .graph-canvas {
            position: relative;
            background-color: #1a1625;
            background-image: 
                linear-gradient(rgba(139, 92, 246, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(139, 92, 246, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            background-position: 0 0;
            overflow: hidden;
            cursor: grab;
        }

        .graph-canvas.panning {
            cursor: grabbing;
        }

        .graph-viewport {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-origin: 0 0;
            transition: transform 0.1s ease-out;
        }

        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 5;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(30, 25, 45, 0.95);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 8px;
            color: #c4b5fd;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: rgba(139, 92, 246, 0.25);
            border-color: rgba(139, 92, 246, 0.5);
        }

        .zoom-level {
            font-size: 11px;
            color: #9ca3af;
            text-align: center;
            padding: 4px;
            background: rgba(30, 25, 45, 0.95);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 6px;
        }

        .canvas-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }

        .node {
            position: absolute;
            background: rgba(30, 25, 45, 0.95);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 12px;
            padding: 12px;
            min-width: 180px;
            cursor: move;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .node.selected {
            border-color: #8b5cf6;
            box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.3);
        }

        .node.multi-selected {
            border-color: #a78bfa;
            box-shadow: 0 0 0 2px rgba(167, 139, 250, 0.5);
        }

        .selection-box {
            position: absolute;
            border: 2px dashed #8b5cf6;
            background: rgba(139, 92, 246, 0.1);
            pointer-events: none;
            z-index: 1000;
        }

        .node-header {
            font-weight: 600;
            margin-bottom: 12px;
            color: #a78bfa;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .node-delete {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #fca5a5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .node:hover .node-delete {
            opacity: 1;
        }

        .node-delete:hover {
            background: rgba(239, 68, 68, 0.3);
        }

        .node-port {
            margin: 8px 0;
            display: flex;
            align-items: center;
            font-size: 12px;
        }

        .port-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(139, 92, 246, 0.3);
            border: 2px solid #8b5cf6;
            cursor: crosshair;
            transition: all 0.2s;
        }

        .port-dot:hover {
            transform: scale(1.3);
            background: #8b5cf6;
        }

        .port-dot.output {
            margin-left: auto;
        }

        .port-label {
            margin: 0 8px;
            color: #d1d5db;
        }

        .node-control {
            margin: 8px 0;
        }

        .node-control label {
            display: block;
            font-size: 11px;
            color: #9ca3af;
            margin-bottom: 4px;
        }

        .node-control input,
        .node-control select {
            width: 100%;
            padding: 6px 8px;
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 6px;
            color: #e8e3f0;
            font-size: 12px;
        }

        .node-control input[type="color"] {
            height: 32px;
            cursor: pointer;
        }

        .node-control input[type="range"] {
            padding: 0;
        }

        .right-panel {
            background: rgba(25, 20, 35, 0.6);
            border-left: 1px solid rgba(139, 92, 246, 0.2);
            display: flex;
            flex-direction: column;
        }

        .preview-section {
            flex: 1;
            padding: 20px;
            border-bottom: 1px solid rgba(139, 92, 246, 0.2);
            display: flex;
            flex-direction: column;
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #c4b5fd;
        }

        #preview-canvas {
            flex: 1;
            border-radius: 12px;
            background: #000;
            min-height: 300px;
        }

        .code-section {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .code-editor {
            flex: 1;
            background: rgba(15, 10, 25, 0.8);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 8px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #e8e3f0;
            overflow-y: auto;
            white-space: pre;
            line-height: 1.6;
        }

        .keyword { color: #c792ea; }
        .type { color: #82aaff; }
        .function { color: #ffcb6b; }
        .number { color: #f78c6c; }
        .comment { color: #676e95; }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(139, 92, 246, 0.05);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(139, 92, 246, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(139, 92, 246, 0.5);
        }

        .connection {
            stroke: #8b5cf6;
            stroke-width: 2;
            fill: none;
            opacity: 0.6;
            filter: drop-shadow(0 0 4px rgba(139, 92, 246, 0.5));
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 0.9; }
        }

        .temp-connection {
            stroke: #a78bfa;
            stroke-width: 2;
            fill: none;
            opacity: 0.4;
            stroke-dasharray: 5, 5;
            animation: dash 0.5s linear infinite;
        }

        @keyframes dash {
            to { stroke-dashoffset: -10; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">‚ú® Material Graph Playground</div>
            <div class="header-controls">
                <span class="hint-text" id="hintText" style="display: none;">
                    <span class="hint-icon">üí°</span>
                    <span>Try dragging a node from the left panel to start!</span>
                </span>
                <button class="btn" onclick="loadTemplate('rainbow')">üåà Rainbow</button>
                <button class="btn" onclick="loadTemplate('waves')">üåä Waves</button>
                <button class="btn" onclick="toggleSnap()" id="snapBtn">üìê Snap: ON</button>
                <button class="btn" onclick="toggleCamera()">üì∑ <span id="cameraText">Pause</span></button>
                <button class="btn" onclick="clearGraph()">Clear All</button>
                <button class="btn primary" onclick="compileShader()">Apply Shader</button>
            </div>
        </div>

        <div class="node-palette">
            <div class="palette-section">
                <div class="palette-title">üé® Colors</div>
                <div class="node-item" draggable="true" data-node-type="color">
                    <div>Color Picker</div>
                    <div class="node-item-desc">Choose any color</div>
                </div>
                <div class="node-item" draggable="true" data-node-type="gradient">
                    <div>Gradient</div>
                    <div class="node-item-desc">Smooth color blend</div>
                </div>
            </div>

            <div class="palette-section">
                <div class="palette-title">üåä Patterns</div>
                <div class="node-item" draggable="true" data-node-type="checkerboard">
                    <div>Checkerboard</div>
                    <div class="node-item-desc">Classic pattern</div>
                </div>
                <div class="node-item" draggable="true" data-node-type="noise">
                    <div>Noise</div>
                    <div class="node-item-desc">Random texture</div>
                </div>
                <div class="node-item" draggable="true" data-node-type="waves">
                    <div>Waves</div>
                    <div class="node-item-desc">Wavy patterns</div>
                </div>
                <div class="node-item" draggable="true" data-node-type="spiral">
                    <div>Spiral</div>
                    <div class="node-item-desc">Twisting vortex</div>
                </div>
                <div class="node-item" draggable="true" data-node-type="voronoi">
                    <div>Voronoi</div>
                    <div class="node-item-desc">Organic cells</div>
                </div>
                <div class="node-item" draggable="true" data-node-type="stripes">
                    <div>Stripes</div>
                    <div class="node-item-desc">Linear stripes</div>
                </div>
                <div class="node-item" draggable="true" data-node-type="dots">
                    <div>Dots</div>
                    <div class="node-item-desc">Polka dot pattern</div>
                </div>
            </div>

            <div class="palette-section">
                <div class="palette-title">üîß Effects</div>
                <div class="node-item" draggable="true" data-node-type="mix">
                    <div>Mix</div>
                    <div class="node-item-desc">Blend two inputs</div>
                </div>
                <div class="node-item" draggable="true" data-node-type="brightness">
                    <div>Brightness</div>
                    <div class="node-item-desc">Adjust lightness</div>
                </div>
                <div class="node-item" draggable="true" data-node-type="multiply">
                    <div>Multiply</div>
                    <div class="node-item-desc">Multiply colors</div>
                </div>
                <div class="node-item" draggable="true" data-node-type="add">
                    <div>Add</div>
                    <div class="node-item-desc">Add colors together</div>
                </div>
                <div class="node-item" draggable="true" data-node-type="contrast">
                    <div>Contrast</div>
                    <div class="node-item-desc">Enhance contrast</div>
                </div>
                <div class="node-item" draggable="true" data-node-type="hsv">
                    <div>HSV Adjust</div>
                    <div class="node-item-desc">Hue/Saturation</div>
                </div>
                <div class="node-item" draggable="true" data-node-type="invert">
                    <div>Invert</div>
                    <div class="node-item-desc">Flip colors</div>
                </div>
                <div class="node-item" draggable="true" data-node-type="posterize">
                    <div>Posterize</div>
                    <div class="node-item-desc">Reduce colors</div>
                </div>
            </div>

            <div class="palette-section">
                <div class="palette-title">‚öôÔ∏è Inputs</div>
                <div class="node-item" draggable="true" data-node-type="uv">
                    <div>UV Coordinates</div>
                    <div class="node-item-desc">Position on surface</div>
                </div>
                <div class="node-item" draggable="true" data-node-type="time">
                    <div>Time</div>
                    <div class="node-item-desc">Animate things!</div>
                </div>
            </div>

            <div class="palette-section">
                <div class="palette-title">üî¢ Math</div>
                <div class="node-item" draggable="true" data-node-type="sine">
                    <div>Sine Wave</div>
                    <div class="node-item-desc">Smooth oscillation</div>
                </div>
                <div class="node-item" draggable="true" data-node-type="power">
                    <div>Power</div>
                    <div class="node-item-desc">Exponential curve</div>
                </div>
                <div class="node-item" draggable="true" data-node-type="clamp">
                    <div>Clamp</div>
                    <div class="node-item-desc">Limit range</div>
                </div>
            </div>

            <div class="palette-section">
                <div class="palette-title">üì§ Output</div>
                <div class="node-item" draggable="true" data-node-type="output">
                    <div>Material Output</div>
                    <div class="node-item-desc">Final result</div>
                </div>
            </div>
        </div>

        <div class="graph-canvas" id="graphCanvas">
            <svg class="canvas-svg" id="connectionsSvg"></svg>
            <div class="graph-viewport" id="graphViewport">
            </div>
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()">+</button>
                <div class="zoom-level" id="zoomLevel">100%</div>
                <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
                <button class="zoom-btn" onclick="resetView()" title="Reset View">‚äô</button>
            </div>
        </div>

        <div class="resize-handle vertical left" id="leftHandle"></div>
        <div class="resize-handle vertical right" id="rightHandle"></div>

        <div class="right-panel">
            <div class="preview-section">
                <div class="section-title">üé≠ Live Preview</div>
                <canvas id="preview-canvas"></canvas>
            </div>
            <div class="code-section">
                <div class="section-title">‚ö° Generated Shader</div>
                <div class="code-editor" id="shaderCode"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Graph state
        let nodes = [];
        let connections = [];
        let nodeIdCounter = 0;
        let selectedNode = null;
        let draggedNode = null;
        let connectingFrom = null;
        let tempConnection = null;
        let cameraRotating = true;

        // Pan and zoom state
        let panX = 0;
        let panY = 0;
        let zoom = 1;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let snapToGrid = true;
        let gridSize = 20;

        // Panel resize state
        let leftPanelWidth = 280;
        let rightPanelWidth = 400;
        let isResizingLeft = false;
        let isResizingRight = false;

        // Multi-select state
        let selectedNodes = new Set();
        let isSelecting = false;
        let selectionStart = { x: 0, y: 0 };
        let selectionBox = null;

        // Three.js setup
        const canvas = document.getElementById('preview-canvas');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        
        camera.position.z = 3;
        
        let sphere = new THREE.Mesh(
            new THREE.SphereGeometry(1, 64, 64),
            new THREE.MeshBasicMaterial({ color: 0x8b5cf6 })
        );
        scene.add(sphere);

        function resizePreview() {
            const rect = canvas.getBoundingClientRect();
            renderer.setSize(rect.width, rect.height);
            camera.aspect = rect.width / rect.height;
            camera.updateProjectionMatrix();
        }
        resizePreview();
        window.addEventListener('resize', resizePreview);

        function animate() {
            requestAnimationFrame(animate);
            if (cameraRotating) {
                sphere.rotation.y += 0.005;
                sphere.rotation.x += 0.003;
            }
            renderer.render(scene, camera);
        }
        animate();

        // Node creation
        function createNode(type, x, y) {
            const node = {
                id: nodeIdCounter++,
                type: type,
                x: x,
                y: y,
                inputs: [],
                outputs: [],
                params: {}
            };

            switch(type) {
                case 'color':
                    node.outputs = ['color'];
                    node.params.color = '#8b5cf6';
                    break;
                case 'gradient':
                    node.outputs = ['color'];
                    node.params.color1 = '#8b5cf6';
                    node.params.color2 = '#ec4899';
                    node.params.direction = 'vertical';
                    break;
                case 'checkerboard':
                    node.outputs = ['pattern'];
                    node.params.scale = 5;
                    break;
                case 'noise':
                    node.outputs = ['pattern'];
                    node.params.scale = 3;
                    break;
                case 'waves':
                    node.outputs = ['pattern'];
                    node.params.frequency = 5;
                    node.params.speed = 1;
                    break;
                case 'spiral':
                    node.outputs = ['pattern'];
                    node.params.tightness = 5;
                    node.params.speed = 1;
                    break;
                case 'voronoi':
                    node.outputs = ['pattern'];
                    node.params.cells = 8;
                    break;
                case 'stripes':
                    node.outputs = ['pattern'];
                    node.params.count = 10;
                    node.params.angle = 0;
                    break;
                case 'dots':
                    node.outputs = ['pattern'];
                    node.params.size = 0.3;
                    node.params.spacing = 5;
                    break;
                case 'mix':
                    node.inputs = ['input1', 'input2'];
                    node.outputs = ['result'];
                    node.params.mix = 0.5;
                    break;
                case 'brightness':
                    node.inputs = ['input'];
                    node.outputs = ['result'];
                    node.params.brightness = 1.0;
                    break;
                case 'multiply':
                    node.inputs = ['input1', 'input2'];
                    node.outputs = ['result'];
                    break;
                case 'add':
                    node.inputs = ['input1', 'input2'];
                    node.outputs = ['result'];
                    break;
                case 'contrast':
                    node.inputs = ['input'];
                    node.outputs = ['result'];
                    node.params.contrast = 1.0;
                    break;
                case 'hsv':
                    node.inputs = ['input'];
                    node.outputs = ['result'];
                    node.params.hueShift = 0;
                    node.params.saturation = 1.0;
                    node.params.value = 1.0;
                    break;
                case 'invert':
                    node.inputs = ['input'];
                    node.outputs = ['result'];
                    break;
                case 'posterize':
                    node.inputs = ['input'];
                    node.outputs = ['result'];
                    node.params.levels = 4;
                    break;
                case 'uv':
                    node.outputs = ['UV'];
                    node.params.scale = 1.0;
                    node.params.offsetX = 0.0;
                    node.params.offsetY = 0.0;
                    break;
                case 'time':
                    node.outputs = ['value'];
                    node.params.speed = 1.0;
                    break;
                case 'sine':
                    node.inputs = ['input'];
                    node.outputs = ['result'];
                    node.params.frequency = 1.0;
                    node.params.amplitude = 1.0;
                    break;
                case 'power':
                    node.inputs = ['input'];
                    node.outputs = ['result'];
                    node.params.exponent = 2.0;
                    break;
                case 'clamp':
                    node.inputs = ['input'];
                    node.outputs = ['result'];
                    node.params.min = 0.0;
                    node.params.max = 1.0;
                    break;
                case 'output':
                    node.inputs = ['color'];
                    break;
            }

            nodes.push(node);
            renderGraph();
            updateShaderCode();
            updateHint();
            return node;
        }

        function renderGraph() {
            const viewport = document.getElementById('graphViewport');
            
            // Clear existing nodes
            const existingNodes = viewport.querySelectorAll('.node');
            existingNodes.forEach(n => n.remove());

            // Render nodes
            nodes.forEach(node => {
                const nodeEl = document.createElement('div');
                nodeEl.className = 'node';
                if (selectedNode === node.id) nodeEl.classList.add('selected');
                if (selectedNodes.has(node.id)) nodeEl.classList.add('multi-selected');
                nodeEl.style.left = node.x + 'px';
                nodeEl.style.top = node.y + 'px';
                nodeEl.dataset.nodeId = node.id;

                let html = `
                    <div class="node-header">
                        ${getNodeDisplayName(node.type)}
                        <div class="node-delete" onclick="deleteNode(${node.id})">√ó</div>
                    </div>
                `;

                // Input ports
                node.inputs.forEach((input, i) => {
                    html += `
                        <div class="node-port">
                            <div class="port-dot" data-port-type="input" data-port-index="${i}" data-node-id="${node.id}"></div>
                            <span class="port-label">${input}</span>
                        </div>
                    `;
                });

                // Controls
                Object.keys(node.params).forEach(param => {
                    const value = node.params[param];
                    html += `<div class="node-control">`;
                    
                    if (typeof value === 'number') {
                        if (param === 'mix' || param === 'brightness') {
                            html += `
                                <label>${param}</label>
                                <input type="range" min="0" max="2" step="0.1" value="${value}" 
                                    onchange="updateNodeParam(${node.id}, '${param}', parseFloat(this.value))">
                            `;
                        } else {
                            html += `
                                <label>${param}</label>
                                <input type="number" value="${value}" 
                                    onchange="updateNodeParam(${node.id}, '${param}', parseFloat(this.value))">
                            `;
                        }
                    } else if (param.includes('color')) {
                        html += `
                            <label>${param}</label>
                            <input type="color" value="${value}" 
                                onchange="updateNodeParam(${node.id}, '${param}', this.value)">
                        `;
                    } else if (param === 'direction') {
                        html += `
                            <label>${param}</label>
                            <select onchange="updateNodeParam(${node.id}, '${param}', this.value)">
                                <option value="vertical" ${value === 'vertical' ? 'selected' : ''}>Vertical</option>
                                <option value="horizontal" ${value === 'horizontal' ? 'selected' : ''}>Horizontal</option>
                                <option value="diagonal" ${value === 'diagonal' ? 'selected' : ''}>Diagonal</option>
                            </select>
                        `;
                    }
                    
                    html += `</div>`;
                });

                // Output ports
                node.outputs.forEach((output, i) => {
                    html += `
                        <div class="node-port">
                            <span class="port-label">${output}</span>
                            <div class="port-dot output" data-port-type="output" data-port-index="${i}" data-node-id="${node.id}"></div>
                        </div>
                    `;
                });

                nodeEl.innerHTML = html;
                viewport.appendChild(nodeEl);

                // Add node dragging
                nodeEl.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('port-dot')) return;
                    if (e.target.closest('.node-delete')) return;
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
                    
                    selectedNode = node.id;
                    draggedNode = node;
                    
                    // If clicking on a non-selected node, clear multi-selection (unless ctrl/cmd held)
                    if (!selectedNodes.has(node.id) && !e.ctrlKey && !e.metaKey) {
                        selectedNodes.clear();
                    }
                    
                    // Add to multi-selection if ctrl/cmd held
                    if (e.ctrlKey || e.metaKey) {
                        if (selectedNodes.has(node.id)) {
                            selectedNodes.delete(node.id);
                        } else {
                            selectedNodes.add(node.id);
                        }
                    } else if (!selectedNodes.has(node.id)) {
                        // If not in selection and not holding ctrl, add just this node
                        selectedNodes.add(node.id);
                    }
                    
                    // Account for zoom when calculating offset
                    const rect = viewport.getBoundingClientRect();
                    draggedNode.offsetX = (e.clientX - rect.left) / zoom - node.x;
                    draggedNode.offsetY = (e.clientY - rect.top) / zoom - node.y;
                    draggedNode.lastX = node.x;
                    draggedNode.lastY = node.y;
                    
                    renderGraph();
                });
            });

            // Add port connection handlers
            document.querySelectorAll('.port-dot').forEach(dot => {
                dot.addEventListener('mousedown', startConnection);
            });

            renderConnections();
        }

        function getNodeDisplayName(type) {
            const names = {
                color: 'üé® Color',
                gradient: 'üåà Gradient',
                checkerboard: '‚¨õ Checkerboard',
                noise: 'üåä Noise',
                waves: '„Ä∞Ô∏è Waves',
                spiral: 'üåÄ Spiral',
                voronoi: 'üî∂ Voronoi',
                stripes: 'üìè Stripes',
                dots: '‚ö™ Dots',
                mix: 'üîÄ Mix',
                brightness: 'üí° Brightness',
                multiply: '‚úñÔ∏è Multiply',
                add: '‚ûï Add',
                contrast: '‚óê Contrast',
                hsv: 'üé® HSV',
                invert: '‚ö´‚ö™ Invert',
                posterize: 'üéûÔ∏è Posterize',
                uv: 'üìç UV Coords',
                time: '‚è±Ô∏è Time',
                sine: '„Ä∞Ô∏è Sine',
                power: 'üìà Power',
                clamp: 'üìä Clamp',
                output: 'üì§ Output'
            };
            return names[type] || type;
        }

        function updateNodeParam(nodeId, param, value) {
            const node = nodes.find(n => n.id === nodeId);
            if (node) {
                node.params[param] = value;
                updateShaderCode();
                compileShader();
            }
        }

        function deleteNode(nodeId) {
            nodes = nodes.filter(n => n.id !== nodeId);
            connections = connections.filter(c => 
                c.fromNode !== nodeId && c.toNode !== nodeId
            );
            if (selectedNode === nodeId) selectedNode = null;
            renderGraph();
            updateShaderCode();
            updateHint();
        }

        function startConnection(e) {
            e.stopPropagation();
            const dot = e.target;
            const nodeId = parseInt(dot.dataset.nodeId);
            const portType = dot.dataset.portType;
            const portIndex = parseInt(dot.dataset.portIndex);

            if (portType === 'output') {
                connectingFrom = { nodeId, portIndex };
                
                document.addEventListener('mousemove', drawTempConnection);
                document.addEventListener('mouseup', endConnection);
            }
        }

        function drawTempConnection(e) {
            if (!connectingFrom) return;

            const fromNode = nodes.find(n => n.id === connectingFrom.nodeId);
            const fromEl = document.querySelector(`[data-node-id="${connectingFrom.nodeId}"]`);
            const fromPort = fromEl.querySelectorAll('.port-dot.output')[connectingFrom.portIndex];
            const fromRect = fromPort.getBoundingClientRect();
            const canvasRect = document.getElementById('graphCanvas').getBoundingClientRect();

            const x1 = fromRect.left + fromRect.width / 2 - canvasRect.left;
            const y1 = fromRect.top + fromRect.height / 2 - canvasRect.top;
            const x2 = e.clientX - canvasRect.left;
            const y2 = e.clientY - canvasRect.top;

            const svg = document.getElementById('connectionsSvg');
            const existing = svg.querySelector('.temp-connection');
            if (existing) existing.remove();

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('class', 'temp-connection');
            path.setAttribute('d', createCurvePath(x1, y1, x2, y2));
            svg.appendChild(path);
        }

        function endConnection(e) {
            document.removeEventListener('mousemove', drawTempConnection);
            document.removeEventListener('mouseup', endConnection);

            const svg = document.getElementById('connectionsSvg');
            const temp = svg.querySelector('.temp-connection');
            if (temp) temp.remove();

            const target = e.target;
            if (target.classList.contains('port-dot') && target.dataset.portType === 'input') {
                const toNodeId = parseInt(target.dataset.nodeId);
                const toPortIndex = parseInt(target.dataset.portIndex);

                // Remove existing connection to this input
                connections = connections.filter(c => 
                    !(c.toNode === toNodeId && c.toPort === toPortIndex)
                );

                connections.push({
                    fromNode: connectingFrom.nodeId,
                    fromPort: connectingFrom.portIndex,
                    toNode: toNodeId,
                    toPort: toPortIndex
                });

                renderGraph();
                updateShaderCode();
            }

            connectingFrom = null;
        }

        function renderConnections() {
            const svg = document.getElementById('connectionsSvg');
            svg.querySelectorAll('.connection').forEach(c => c.remove());

            connections.forEach(conn => {
                const fromEl = document.querySelector(`[data-node-id="${conn.fromNode}"]`);
                const toEl = document.querySelector(`[data-node-id="${conn.toNode}"]`);
                
                if (!fromEl || !toEl) return;

                const fromPort = fromEl.querySelectorAll('.port-dot.output')[conn.fromPort];
                const toPort = toEl.querySelectorAll('.port-dot:not(.output)')[conn.toPort];

                const canvasRect = document.getElementById('graphCanvas').getBoundingClientRect();
                const fromRect = fromPort.getBoundingClientRect();
                const toRect = toPort.getBoundingClientRect();

                // Calculate positions relative to canvas (not viewport)
                const x1 = fromRect.left + fromRect.width / 2 - canvasRect.left;
                const y1 = fromRect.top + fromRect.height / 2 - canvasRect.top;
                const x2 = toRect.left + toRect.width / 2 - canvasRect.left;
                const y2 = toRect.top + toRect.height / 2 - canvasRect.top;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', 'connection');
                path.setAttribute('d', createCurvePath(x1, y1, x2, y2));
                svg.appendChild(path);
            });
        }

        function createCurvePath(x1, y1, x2, y2) {
            const dx = Math.abs(x2 - x1);
            const offset = Math.min(dx * 0.5, 100);
            return `M ${x1} ${y1} C ${x1 + offset} ${y1}, ${x2 - offset} ${y2}, ${x2} ${y2}`;
        }

        // Drag and drop from palette - using event delegation
        const palette = document.querySelector('.node-palette');
        
        palette.addEventListener('dragstart', (e) => {
            if (e.target.classList.contains('node-item')) {
                e.dataTransfer.setData('nodeType', e.target.dataset.nodeType);
            }
        });

        // Touch support for mobile
        let touchedNodeType = null;
        let touchStartPos = null;
        
        palette.addEventListener('touchstart', (e) => {
            const nodeItem = e.target.closest('.node-item');
            if (nodeItem) {
                touchedNodeType = nodeItem.dataset.nodeType;
                touchStartPos = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
                nodeItem.style.opacity = '0.5';
            }
        }, { passive: false });

        palette.addEventListener('touchmove', (e) => {
            if (touchedNodeType) {
                e.preventDefault(); // Prevent scrolling while dragging
            }
        }, { passive: false });

        palette.addEventListener('touchend', (e) => {
            const nodeItem = e.target.closest('.node-item');
            if (nodeItem) {
                nodeItem.style.opacity = '1';
            }
            
            if (touchedNodeType && touchStartPos) {
                const touch = e.changedTouches[0];
                const graphCanvas = document.getElementById('graphCanvas');
                const rect = graphCanvas.getBoundingClientRect();
                
                // Check if touch ended over the canvas
                if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
                    touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
                    const rawX = ((touch.clientX - rect.left - panX) / zoom) - 90;
                    const rawY = ((touch.clientY - rect.top - panY) / zoom) - 30;
                    createNode(touchedNodeType, snapToGridPos(rawX), snapToGridPos(rawY));
                }
                
                touchedNodeType = null;
                touchStartPos = null;
            }
        });

        const graphCanvas = document.getElementById('graphCanvas');
        graphCanvas.addEventListener('dragover', (e) => e.preventDefault());
        graphCanvas.addEventListener('drop', (e) => {
            e.preventDefault();
            const nodeType = e.dataTransfer.getData('nodeType');
            if (nodeType) {
                const rect = graphCanvas.getBoundingClientRect();
                // Account for pan and zoom when dropping nodes
                const rawX = ((e.clientX - rect.left - panX) / zoom) - 90;
                const rawY = ((e.clientY - rect.top - panY) / zoom) - 30;
                createNode(nodeType, snapToGridPos(rawX), snapToGridPos(rawY));
            }
        });

        // Mouse move for node dragging
        document.addEventListener('mousemove', (e) => {
            if (draggedNode && !isPanning) {
                const viewport = document.getElementById('graphViewport');
                const rect = viewport.getBoundingClientRect();
                const rawX = (e.clientX - rect.left) / zoom - draggedNode.offsetX;
                const rawY = (e.clientY - rect.top) / zoom - draggedNode.offsetY;
                
                draggedNode.x = snapToGridPos(rawX);
                draggedNode.y = snapToGridPos(rawY);
                
                // If dragging a multi-selected node, move all selected nodes
                if (selectedNodes.has(draggedNode.id)) {
                    const deltaX = draggedNode.x - (draggedNode.lastX || draggedNode.x);
                    const deltaY = draggedNode.y - (draggedNode.lastY || draggedNode.y);
                    
                    selectedNodes.forEach(nodeId => {
                        if (nodeId !== draggedNode.id) {
                            const node = nodes.find(n => n.id === nodeId);
                            if (node) {
                                node.x = snapToGridPos(node.x + deltaX);
                                node.y = snapToGridPos(node.y + deltaY);
                            }
                        }
                    });
                }
                
                draggedNode.lastX = draggedNode.x;
                draggedNode.lastY = draggedNode.y;
                
                renderGraph();
            }
        });

        document.addEventListener('mouseup', () => {
            draggedNode = null;
        });

        // Shader generation
        function updateShaderCode() {
            const code = generateShaderCode();
            const codeEl = document.getElementById('shaderCode');
            codeEl.innerHTML = syntaxHighlight(code);
        }

        function generateShaderCode() {
            const outputNode = nodes.find(n => n.type === 'output');
            if (!outputNode) {
                return '// Add a Material Output node to see the shader!';
            }

            let code = `// Auto-generated shader
<span class="keyword">varying vec2</span> vUv;
<span class="keyword">uniform float</span> time;

`;

            // Helper functions
            code += `<span class="type">vec3</span> <span class="function">hsv2rgb</span>(<span class="type">vec3</span> c) {
    <span class="type">vec4</span> K = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">2.0</span> / <span class="number">3.0</span>, <span class="number">1.0</span> / <span class="number">3.0</span>, <span class="number">3.0</span>);
    <span class="type">vec3</span> p = abs(fract(c.xxx + K.xyz) * <span class="number">6.0</span> - K.www);
    <span class="keyword">return</span> c.z * mix(K.xxx, clamp(p - K.xxx, <span class="number">0.0</span>, <span class="number">1.0</span>), c.y);
}

<span class="type">vec3</span> <span class="function">rgb2hsv</span>(<span class="type">vec3</span> c) {
    <span class="type">vec4</span> K = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">-1.0</span> / <span class="number">3.0</span>, <span class="number">2.0</span> / <span class="number">3.0</span>, <span class="number">-1.0</span>);
    <span class="type">vec4</span> p = mix(<span class="type">vec4</span>(c.bg, K.wz), <span class="type">vec4</span>(c.gb, K.xy), step(c.b, c.g));
    <span class="type">vec4</span> q = mix(<span class="type">vec4</span>(p.xyw, c.r), <span class="type">vec4</span>(c.r, p.yzx), step(p.x, c.r));
    <span class="type">float</span> d = q.x - min(q.w, q.y);
    <span class="type">float</span> e = <span class="number">1.0e-10</span>;
    <span class="keyword">return</span> <span class="type">vec3</span>(abs(q.z + (q.w - q.y) / (<span class="number">6.0</span> * d + e)), d / (q.x + e), q.x);
}

`;

            code += `<span class="keyword">void</span> <span class="function">main</span>() {
    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.0</span>);
    
`;

            code += generateNodeCode(outputNode, 0);
            
            code += `    gl_FragColor = <span class="type">vec4</span>(color, <span class="number">1.0</span>);
}`;

            return code;
        }

        function generateNodeCode(node, inputIndex) {
            const conn = connections.find(c => c.toNode === node.id && c.toPort === inputIndex);
            
            if (!conn) {
                return `    color = <span class="type">vec3</span>(<span class="number">0.5</span>, <span class="number">0.3</span>, <span class="number">0.7</span>); <span class="comment">// Default purple</span>\n`;
            }

            const sourceNode = nodes.find(n => n.id === conn.fromNode);
            let code = '';

            switch(sourceNode.type) {
                case 'color':
                    const rgb = hexToRgb(sourceNode.params.color);
                    code += `    color = <span class="type">vec3</span>(<span class="number">${rgb.r}</span>, <span class="number">${rgb.g}</span>, <span class="number">${rgb.b}</span>);\n`;
                    break;

                case 'gradient':
                    const rgb1 = hexToRgb(sourceNode.params.color1);
                    const rgb2 = hexToRgb(sourceNode.params.color2);
                    const coord = sourceNode.params.direction === 'vertical' ? 'vUv.y' : 
                                sourceNode.params.direction === 'horizontal' ? 'vUv.x' : 
                                '(vUv.x + vUv.y) * 0.5';
                    code += `    color = mix(<span class="type">vec3</span>(<span class="number">${rgb1.r}</span>, <span class="number">${rgb1.g}</span>, <span class="number">${rgb1.b}</span>), <span class="type">vec3</span>(<span class="number">${rgb2.r}</span>, <span class="number">${rgb2.g}</span>, <span class="number">${rgb2.b}</span>), ${coord});\n`;
                    break;

                case 'checkerboard':
                    const scale = sourceNode.params.scale;
                    code += `    <span class="type">vec2</span> checker = floor(vUv * <span class="number">${scale}.0</span>);
    <span class="type">float</span> pattern = mod(checker.x + checker.y, <span class="number">2.0</span>);
    color = <span class="type">vec3</span>(pattern);\n`;
                    break;

                case 'noise':
                    const nscale = sourceNode.params.scale;
                    code += `    <span class="type">float</span> noise = fract(sin(dot(vUv * <span class="number">${nscale}.0</span>, <span class="type">vec2</span>(<span class="number">12.9898</span>, <span class="number">78.233</span>))) * <span class="number">43758.5453</span>);
    color = <span class="type">vec3</span>(noise);\n`;
                    break;

                case 'waves':
                    const freq = sourceNode.params.frequency;
                    const speed = sourceNode.params.speed;
                    code += `    <span class="type">float</span> wave = sin(vUv.x * <span class="number">${freq}.0</span> + time * <span class="number">${speed}.0</span>) * <span class="number">0.5</span> + <span class="number">0.5</span>;
    color = <span class="type">vec3</span>(wave);\n`;
                    break;

                case 'spiral':
                    const tight = sourceNode.params.tightness;
                    const spiralSpeed = sourceNode.params.speed;
                    code += `    <span class="type">vec2</span> centered = vUv - <span class="number">0.5</span>;
    <span class="type">float</span> angle = atan(centered.y, centered.x);
    <span class="type">float</span> radius = length(centered);
    <span class="type">float</span> spiral = sin(angle * <span class="number">${tight}.0</span> + radius * <span class="number">20.0</span> - time * <span class="number">${spiralSpeed}.0</span>) * <span class="number">0.5</span> + <span class="number">0.5</span>;
    color = <span class="type">vec3</span>(spiral);\n`;
                    break;

                case 'voronoi':
                    const cells = sourceNode.params.cells;
                    code += `    <span class="type">vec2</span> gridUV = vUv * <span class="number">${cells}.0</span>;
    <span class="type">vec2</span> gridID = floor(gridUV);
    <span class="type">vec2</span> gridPos = fract(gridUV);
    <span class="type">float</span> minDist = <span class="number">1.0</span>;
    <span class="keyword">for</span>(<span class="type">float</span> y = <span class="number">-1.0</span>; y <= <span class="number">1.0</span>; y++) {
        <span class="keyword">for</span>(<span class="type">float</span> x = <span class="number">-1.0</span>; x <= <span class="number">1.0</span>; x++) {
            <span class="type">vec2</span> neighbor = <span class="type">vec2</span>(x, y);
            <span class="type">vec2</span> point = neighbor + fract(sin(dot(gridID + neighbor, <span class="type">vec2</span>(<span class="number">12.9898</span>, <span class="number">78.233</span>))) * <span class="number">43758.5453</span>);
            <span class="type">float</span> dist = length(gridPos - point);
            minDist = min(minDist, dist);
        }
    }
    color = <span class="type">vec3</span>(minDist);\n`;
                    break;

                case 'stripes':
                    const count = sourceNode.params.count;
                    const angle = sourceNode.params.angle;
                    code += `    <span class="type">float</span> angleRad = radians(<span class="number">${angle}.0</span>);
    <span class="type">vec2</span> rotated = <span class="type">vec2</span>(
        vUv.x * cos(angleRad) - vUv.y * sin(angleRad),
        vUv.x * sin(angleRad) + vUv.y * cos(angleRad)
    );
    <span class="type">float</span> stripes = mod(floor(rotated.x * <span class="number">${count}.0</span>), <span class="number">2.0</span>);
    color = <span class="type">vec3</span>(stripes);\n`;
                    break;

                case 'dots':
                    const dotSize = sourceNode.params.size;
                    const spacing = sourceNode.params.spacing;
                    code += `    <span class="type">vec2</span> dotUV = fract(vUv * <span class="number">${spacing}.0</span>) - <span class="number">0.5</span>;
    <span class="type">float</span> dots = step(length(dotUV), <span class="number">${dotSize}</span>);
    color = <span class="type">vec3</span>(dots);\n`;
                    break;

                case 'brightness':
                    code += generateNodeCode(sourceNode, 0);
                    code += `    color *= <span class="number">${sourceNode.params.brightness}</span>;\n`;
                    break;

                case 'multiply':
                    const hasMul1 = connections.find(c => c.toNode === sourceNode.id && c.toPort === 0);
                    const hasMul2 = connections.find(c => c.toNode === sourceNode.id && c.toPort === 1);
                    
                    if (hasMul1) code += generateNodeCode(sourceNode, 0);
                    else code += `    color = <span class="type">vec3</span>(<span class="number">1.0</span>);\n`;
                    
                    code += `    <span class="type">vec3</span> mul1 = color;\n`;
                    
                    if (hasMul2) code += generateNodeCode(sourceNode, 1);
                    else code += `    color = <span class="type">vec3</span>(<span class="number">1.0</span>);\n`;
                    
                    code += `    color = mul1 * color;\n`;
                    break;

                case 'add':
                    const hasAdd1 = connections.find(c => c.toNode === sourceNode.id && c.toPort === 0);
                    const hasAdd2 = connections.find(c => c.toNode === sourceNode.id && c.toPort === 1);
                    
                    if (hasAdd1) code += generateNodeCode(sourceNode, 0);
                    else code += `    color = <span class="type">vec3</span>(<span class="number">0.0</span>);\n`;
                    
                    code += `    <span class="type">vec3</span> add1 = color;\n`;
                    
                    if (hasAdd2) code += generateNodeCode(sourceNode, 1);
                    else code += `    color = <span class="type">vec3</span>(<span class="number">0.0</span>);\n`;
                    
                    code += `    color = add1 + color;\n`;
                    break;

                case 'uv':
                    const uvScale = sourceNode.params.scale;
                    const uvOffsetX = sourceNode.params.offsetX;
                    const uvOffsetY = sourceNode.params.offsetY;
                    code += `    <span class="type">vec2</span> uvCoord = (vUv + <span class="type">vec2</span>(<span class="number">${uvOffsetX}</span>, <span class="number">${uvOffsetY}</span>)) * <span class="number">${uvScale}</span>;
    color = <span class="type">vec3</span>(uvCoord, <span class="number">0.5</span>);\n`;
                    break;

                case 'time':
                    const timeSpeed = sourceNode.params.speed;
                    code += `    <span class="type">float</span> timeVal = time * <span class="number">${timeSpeed}</span>;
    color = <span class="type">vec3</span>(sin(timeVal) * <span class="number">0.5</span> + <span class="number">0.5</span>);\n`;
                    break;

                case 'contrast':
                    code += generateNodeCode(sourceNode, 0);
                    const contrastVal = sourceNode.params.contrast;
                    code += `    color = (color - <span class="number">0.5</span>) * <span class="number">${contrastVal}</span> + <span class="number">0.5</span>;\n`;
                    break;

                case 'hsv':
                    code += generateNodeCode(sourceNode, 0);
                    const hueShift = sourceNode.params.hueShift / 360.0;
                    const satMult = sourceNode.params.saturation;
                    const valMult = sourceNode.params.value;
                    code += `    <span class="type">vec3</span> hsv = rgb2hsv(color);
    hsv.x = fract(hsv.x + <span class="number">${hueShift}</span>);
    hsv.y *= <span class="number">${satMult}</span>;
    hsv.z *= <span class="number">${valMult}</span>;
    color = hsv2rgb(hsv);\n`;
                    break;

                case 'invert':
                    code += generateNodeCode(sourceNode, 0);
                    code += `    color = <span class="type">vec3</span>(<span class="number">1.0</span>) - color;\n`;
                    break;

                case 'posterize':
                    code += generateNodeCode(sourceNode, 0);
                    const levels = sourceNode.params.levels;
                    code += `    color = floor(color * <span class="number">${levels}.0</span>) / <span class="number">${levels}.0</span>;\n`;
                    break;

                case 'sine':
                    code += generateNodeCode(sourceNode, 0);
                    const sineFreq = sourceNode.params.frequency;
                    const sineAmp = sourceNode.params.amplitude;
                    code += `    color = sin(color * <span class="number">${sineFreq}</span> * <span class="number">6.28318</span>) * <span class="number">${sineAmp}</span> * <span class="number">0.5</span> + <span class="number">0.5</span>;\n`;
                    break;

                case 'power':
                    code += generateNodeCode(sourceNode, 0);
                    const exponent = sourceNode.params.exponent;
                    code += `    color = pow(color, <span class="type">vec3</span>(<span class="number">${exponent}</span>));\n`;
                    break;

                case 'clamp':
                    code += generateNodeCode(sourceNode, 0);
                    const clampMin = sourceNode.params.min;
                    const clampMax = sourceNode.params.max;
                    code += `    color = clamp(color, <span class="type">vec3</span>(<span class="number">${clampMin}</span>), <span class="type">vec3</span>(<span class="number">${clampMax}</span>));\n`;
                    break;

                case 'mix':
                    const hasInput1 = connections.find(c => c.toNode === sourceNode.id && c.toPort === 0);
                    const hasInput2 = connections.find(c => c.toNode === sourceNode.id && c.toPort === 1);
                    
                    if (hasInput1) code += generateNodeCode(sourceNode, 0);
                    else code += `    <span class="type">vec3</span> input1 = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);\n`;
                    
                    code += `    <span class="type">vec3</span> temp = color;\n`;
                    
                    if (hasInput2) code += generateNodeCode(sourceNode, 1);
                    else code += `    color = <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);\n`;
                    
                    code += `    color = mix(temp, color, <span class="number">${sourceNode.params.mix}</span>);\n`;
                    break;
            }

            return code;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: (parseInt(result[1], 16) / 255).toFixed(3),
                g: (parseInt(result[2], 16) / 255).toFixed(3),
                b: (parseInt(result[3], 16) / 255).toFixed(3)
            } : { r: 0.5, g: 0.3, b: 0.7 };
        }

        function syntaxHighlight(code) {
            return code;
        }

        function compileShader() {
            const outputNode = nodes.find(n => n.type === 'output');
            if (!outputNode) return;

            const fragmentShader = generateActualShader();
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: fragmentShader
            });

            sphere.material = material;

            function animateShader() {
                material.uniforms.time.value = performance.now() * 0.001;
                requestAnimationFrame(animateShader);
            }
            animateShader();
        }

        function generateActualShader() {
            const outputNode = nodes.find(n => n.type === 'output');
            if (!outputNode) return '';

            let shader = `
                varying vec2 vUv;
                uniform float time;

                vec3 hsv2rgb(vec3 c) {
                    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                }

                vec3 rgb2hsv(vec3 c) {
                    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
                    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
                    float d = q.x - min(q.w, q.y);
                    float e = 1.0e-10;
                    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
                }

                void main() {
                    vec3 color = vec3(0.0);
                    ${generateActualNodeCode(outputNode, 0)}
                    gl_FragColor = vec4(color, 1.0);
                }
            `;

            return shader;
        }

        function generateActualNodeCode(node, inputIndex) {
            const conn = connections.find(c => c.toNode === node.id && c.toPort === inputIndex);
            
            if (!conn) {
                return `color = vec3(0.54, 0.36, 0.96);`;
            }

            const sourceNode = nodes.find(n => n.id === conn.fromNode);
            let code = '';

            switch(sourceNode.type) {
                case 'color':
                    const rgb = hexToRgb(sourceNode.params.color);
                    code += `color = vec3(${rgb.r}, ${rgb.g}, ${rgb.b});`;
                    break;

                case 'gradient':
                    const rgb1 = hexToRgb(sourceNode.params.color1);
                    const rgb2 = hexToRgb(sourceNode.params.color2);
                    const coord = sourceNode.params.direction === 'vertical' ? 'vUv.y' : 
                                sourceNode.params.direction === 'horizontal' ? 'vUv.x' : 
                                '(vUv.x + vUv.y) * 0.5';
                    code += `color = mix(vec3(${rgb1.r}, ${rgb1.g}, ${rgb1.b}), vec3(${rgb2.r}, ${rgb2.g}, ${rgb2.b}), ${coord});`;
                    break;

                case 'checkerboard':
                    const scale = sourceNode.params.scale;
                    code += `
                        vec2 checker = floor(vUv * ${scale}.0);
                        float pattern = mod(checker.x + checker.y, 2.0);
                        color = vec3(pattern);
                    `;
                    break;

                case 'noise':
                    const nscale = sourceNode.params.scale;
                    code += `
                        float noise = fract(sin(dot(vUv * ${nscale}.0, vec2(12.9898, 78.233))) * 43758.5453);
                        color = vec3(noise);
                    `;
                    break;

                case 'waves':
                    const freq = sourceNode.params.frequency;
                    const speed = sourceNode.params.speed;
                    code += `
                        float wave = sin(vUv.x * ${freq}.0 + time * ${speed}.0) * 0.5 + 0.5;
                        color = vec3(wave);
                    `;
                    break;

                case 'spiral':
                    const tight = sourceNode.params.tightness;
                    const spiralSpeed = sourceNode.params.speed;
                    code += `
                        vec2 centered = vUv - 0.5;
                        float angle = atan(centered.y, centered.x);
                        float radius = length(centered);
                        float spiral = sin(angle * ${tight}.0 + radius * 20.0 - time * ${spiralSpeed}.0) * 0.5 + 0.5;
                        color = vec3(spiral);
                    `;
                    break;

                case 'voronoi':
                    const cells = sourceNode.params.cells;
                    code += `
                        vec2 gridUV = vUv * ${cells}.0;
                        vec2 gridID = floor(gridUV);
                        vec2 gridPos = fract(gridUV);
                        float minDist = 1.0;
                        for(float y = -1.0; y <= 1.0; y++) {
                            for(float x = -1.0; x <= 1.0; x++) {
                                vec2 neighbor = vec2(x, y);
                                vec2 point = neighbor + fract(sin(dot(gridID + neighbor, vec2(12.9898, 78.233))) * 43758.5453);
                                float dist = length(gridPos - point);
                                minDist = min(minDist, dist);
                            }
                        }
                        color = vec3(minDist);
                    `;
                    break;

                case 'stripes':
                    const count = sourceNode.params.count;
                    const angle = sourceNode.params.angle;
                    code += `
                        float angleRad = radians(${angle}.0);
                        vec2 rotated = vec2(
                            vUv.x * cos(angleRad) - vUv.y * sin(angleRad),
                            vUv.x * sin(angleRad) + vUv.y * cos(angleRad)
                        );
                        float stripes = mod(floor(rotated.x * ${count}.0), 2.0);
                        color = vec3(stripes);
                    `;
                    break;

                case 'dots':
                    const dotSize = sourceNode.params.size;
                    const spacing = sourceNode.params.spacing;
                    code += `
                        vec2 dotUV = fract(vUv * ${spacing}.0) - 0.5;
                        float dots = step(length(dotUV), ${dotSize});
                        color = vec3(dots);
                    `;
                    break;

                case 'brightness':
                    code += generateActualNodeCode(sourceNode, 0);
                    code += `color *= ${sourceNode.params.brightness};`;
                    break;

                case 'multiply':
                    const hasMul1 = connections.find(c => c.toNode === sourceNode.id && c.toPort === 0);
                    const hasMul2 = connections.find(c => c.toNode === sourceNode.id && c.toPort === 1);
                    
                    if (hasMul1) code += generateActualNodeCode(sourceNode, 0);
                    else code += `color = vec3(1.0);`;
                    
                    code += `vec3 mul1 = color;`;
                    
                    if (hasMul2) code += generateActualNodeCode(sourceNode, 1);
                    else code += `color = vec3(1.0);`;
                    
                    code += `color = mul1 * color;`;
                    break;

                case 'add':
                    const hasAdd1 = connections.find(c => c.toNode === sourceNode.id && c.toPort === 0);
                    const hasAdd2 = connections.find(c => c.toNode === sourceNode.id && c.toPort === 1);
                    
                    if (hasAdd1) code += generateActualNodeCode(sourceNode, 0);
                    else code += `color = vec3(0.0);`;
                    
                    code += `vec3 add1 = color;`;
                    
                    if (hasAdd2) code += generateActualNodeCode(sourceNode, 1);
                    else code += `color = vec3(0.0);`;
                    
                    code += `color = add1 + color;`;
                    break;

                case 'uv':
                    const uvScale = sourceNode.params.scale;
                    const uvOffsetX = sourceNode.params.offsetX;
                    const uvOffsetY = sourceNode.params.offsetY;
                    code += `
                        vec2 uvCoord = (vUv + vec2(${uvOffsetX}, ${uvOffsetY})) * ${uvScale};
                        color = vec3(uvCoord, 0.5);
                    `;
                    break;

                case 'time':
                    const timeSpeed = sourceNode.params.speed;
                    code += `
                        float timeVal = time * ${timeSpeed};
                        color = vec3(sin(timeVal) * 0.5 + 0.5);
                    `;
                    break;

                case 'contrast':
                    code += generateActualNodeCode(sourceNode, 0);
                    const contrastVal = sourceNode.params.contrast;
                    code += `color = (color - 0.5) * ${contrastVal} + 0.5;`;
                    break;

                case 'hsv':
                    code += generateActualNodeCode(sourceNode, 0);
                    const hueShift = sourceNode.params.hueShift / 360.0;
                    const satMult = sourceNode.params.saturation;
                    const valMult = sourceNode.params.value;
                    code += `
                        vec3 hsv = rgb2hsv(color);
                        hsv.x = fract(hsv.x + ${hueShift});
                        hsv.y *= ${satMult};
                        hsv.z *= ${valMult};
                        color = hsv2rgb(hsv);
                    `;
                    break;

                case 'invert':
                    code += generateActualNodeCode(sourceNode, 0);
                    code += `color = vec3(1.0) - color;`;
                    break;

                case 'posterize':
                    code += generateActualNodeCode(sourceNode, 0);
                    const levels = sourceNode.params.levels;
                    code += `color = floor(color * ${levels}.0) / ${levels}.0;`;
                    break;

                case 'sine':
                    code += generateActualNodeCode(sourceNode, 0);
                    const sineFreq = sourceNode.params.frequency;
                    const sineAmp = sourceNode.params.amplitude;
                    code += `color = sin(color * ${sineFreq} * 6.28318) * ${sineAmp} * 0.5 + 0.5;`;
                    break;

                case 'power':
                    code += generateActualNodeCode(sourceNode, 0);
                    const exponent = sourceNode.params.exponent;
                    code += `color = pow(color, vec3(${exponent}));`;
                    break;

                case 'clamp':
                    code += generateActualNodeCode(sourceNode, 0);
                    const clampMin = sourceNode.params.min;
                    const clampMax = sourceNode.params.max;
                    code += `color = clamp(color, vec3(${clampMin}), vec3(${clampMax}));`;
                    break;

                case 'mix':
                    const hasInput1 = connections.find(c => c.toNode === sourceNode.id && c.toPort === 0);
                    const hasInput2 = connections.find(c => c.toNode === sourceNode.id && c.toPort === 1);
                    
                    if (hasInput1) code += generateActualNodeCode(sourceNode, 0);
                    else code += `vec3 input1 = vec3(1.0, 0.0, 0.0);`;
                    
                    code += `vec3 temp = color;`;
                    
                    if (hasInput2) code += generateActualNodeCode(sourceNode, 1);
                    else code += `color = vec3(0.0, 0.0, 1.0);`;
                    
                    code += `color = mix(temp, color, ${sourceNode.params.mix});`;
                    break;
            }

            return code;
        }

        function clearGraph() {
            if (confirm('Clear all nodes and connections?')) {
                nodes = [];
                connections = [];
                selectedNode = null;
                renderGraph();
                updateShaderCode();
                updateHint();
                
                sphere.material = new THREE.MeshBasicMaterial({ color: 0x8b5cf6 });
            }
        }

        function toggleCamera() {
            cameraRotating = !cameraRotating;
            document.getElementById('cameraText').textContent = cameraRotating ? 'Pause' : 'Play';
        }

        function toggleSnap() {
            snapToGrid = !snapToGrid;
            document.getElementById('snapBtn').textContent = snapToGrid ? 'üìê Snap: ON' : 'üìê Snap: OFF';
        }

        function snapToGridPos(value) {
            if (!snapToGrid) return value;
            return Math.round(value / gridSize) * gridSize;
        }

        function loadTemplate(templateName) {
            clearGraph();
            nodes = [];
            connections = [];
            nodeIdCounter = 0;

            if (templateName === 'rainbow') {
                // Create a rainbow gradient mixing example
                const grad1 = createNode('gradient', 100, 100);
                grad1.params.color1 = '#ff0080';
                grad1.params.color2 = '#00ffff';
                grad1.params.direction = 'horizontal';

                const grad2 = createNode('gradient', 100, 250);
                grad2.params.color1 = '#ffff00';
                grad2.params.color2 = '#8000ff';
                grad2.params.direction = 'vertical';

                const mix = createNode('mix', 350, 175);
                mix.params.mix = 0.5;

                const output = createNode('output', 600, 175);

                connections = [
                    { fromNode: grad1.id, fromPort: 0, toNode: mix.id, toPort: 0 },
                    { fromNode: grad2.id, fromPort: 0, toNode: mix.id, toPort: 1 },
                    { fromNode: mix.id, fromPort: 0, toNode: output.id, toPort: 0 }
                ];
            } else if (templateName === 'waves') {
                // Create animated waves pattern
                const waves = createNode('waves', 100, 100);
                waves.params.frequency = 10;
                waves.params.speed = 2;

                const color1 = createNode('color', 100, 250);
                color1.params.color = '#0080ff';

                const color2 = createNode('color', 100, 380);
                color2.params.color = '#00ff80';

                const mix = createNode('mix', 350, 175);
                mix.params.mix = 0.5;

                const mult = createNode('multiply', 350, 320);

                const output = createNode('output', 600, 250);

                connections = [
                    { fromNode: color1.id, fromPort: 0, toNode: mix.id, toPort: 0 },
                    { fromNode: color2.id, fromPort: 0, toNode: mix.id, toPort: 1 },
                    { fromNode: mix.id, fromPort: 0, toNode: mult.id, toPort: 0 },
                    { fromNode: waves.id, fromPort: 0, toNode: mult.id, toPort: 1 },
                    { fromNode: mult.id, fromPort: 0, toNode: output.id, toPort: 0 }
                ];
            }

            renderGraph();
            updateShaderCode();
            compileShader();
            updateHint();
        }

        // Initialize
        updateShaderCode();
        updateHint();
        initializePanZoom();
        initializeResize();

        function updateHint() {
            const hint = document.getElementById('hintText');
            if (nodes.length === 0) {
                hint.style.display = 'flex';
            } else {
                hint.style.display = 'none';
            }
        }

        // Pan and zoom functionality
        function initializePanZoom() {
            const canvas = document.getElementById('graphCanvas');
            const viewport = document.getElementById('graphViewport');

            // Mouse wheel zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Zoom towards mouse position
                const newZoom = Math.max(0.1, Math.min(3, zoom * delta));
                const zoomChange = newZoom / zoom;
                
                panX = mouseX - (mouseX - panX) * zoomChange;
                panY = mouseY - (mouseY - panY) * zoomChange;
                zoom = newZoom;

                updateViewportTransform();
            });

            // Touch support for pinch zoom and pan
            let touchStartDistance = 0;
            let touchStartZoom = 1;
            let lastTouchX = 0;
            let lastTouchY = 0;
            let isTouchPanning = false;

            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    // Pinch zoom
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                    touchStartZoom = zoom;
                } else if (e.touches.length === 1 && !e.target.closest('.node')) {
                    // Single finger pan
                    isTouchPanning = true;
                    lastTouchX = e.touches[0].clientX;
                    lastTouchY = e.touches[0].clientY;
                }
            }, { passive: true });

            canvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    // Pinch zoom
                    e.preventDefault();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const scale = distance / touchStartDistance;
                    zoom = Math.max(0.1, Math.min(3, touchStartZoom * scale));
                    updateViewportTransform();
                } else if (e.touches.length === 1 && isTouchPanning) {
                    // Pan
                    e.preventDefault();
                    const deltaX = e.touches[0].clientX - lastTouchX;
                    const deltaY = e.touches[0].clientY - lastTouchY;
                    panX += deltaX;
                    panY += deltaY;
                    lastTouchX = e.touches[0].clientX;
                    lastTouchY = e.touches[0].clientY;
                    updateViewportTransform();
                    renderConnections();
                }
            }, { passive: false });

            canvas.addEventListener('touchend', (e) => {
                isTouchPanning = false;
            });

            // Pan with middle mouse, shift + drag, or right click
            canvas.addEventListener('mousedown', (e) => {
                // Don't start panning if we're over a node or port
                const isOverNode = e.target.closest('.node');
                const isOverPort = e.target.classList.contains('port-dot');
                const isOverControl = e.target.closest('.zoom-controls');
                
                if (isOverNode || isOverPort || isOverControl) {
                    return;
                }
                
                // Left click on background starts box selection
                if (e.button === 0 && !e.shiftKey) {
                    isSelecting = true;
                    const rect = canvas.getBoundingClientRect();
                    selectionStart.x = e.clientX - rect.left;
                    selectionStart.y = e.clientY - rect.top;
                    
                    // Clear previous selection unless holding ctrl/cmd
                    if (!e.ctrlKey && !e.metaKey) {
                        selectedNodes.clear();
                        renderGraph();
                    }
                    
                    // Create selection box
                    selectionBox = document.createElement('div');
                    selectionBox.className = 'selection-box';
                    selectionBox.style.left = selectionStart.x + 'px';
                    selectionBox.style.top = selectionStart.y + 'px';
                    canvas.appendChild(selectionBox);
                    return;
                }
                
                if (e.button === 1 || e.button === 2 || (e.button === 0 && e.shiftKey)) {
                    e.preventDefault();
                    isPanning = true;
                    panStartX = e.clientX - panX;
                    panStartY = e.clientY - panY;
                    canvas.classList.add('panning');
                }
            });

            // Prevent context menu on right click
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    e.preventDefault();
                    panX = e.clientX - panStartX;
                    panY = e.clientY - panStartY;
                    updateViewportTransform();
                    renderConnections(); // Update connection lines while panning
                } else if (isSelecting && selectionBox) {
                    const rect = canvas.getBoundingClientRect();
                    const currentX = e.clientX - rect.left;
                    const currentY = e.clientY - rect.top;
                    
                    const left = Math.min(selectionStart.x, currentX);
                    const top = Math.min(selectionStart.y, currentY);
                    const width = Math.abs(currentX - selectionStart.x);
                    const height = Math.abs(currentY - selectionStart.y);
                    
                    selectionBox.style.left = left + 'px';
                    selectionBox.style.top = top + 'px';
                    selectionBox.style.width = width + 'px';
                    selectionBox.style.height = height + 'px';
                    
                    // Update selected nodes based on box
                    updateSelectionFromBox(left, top, width, height);
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (isPanning) {
                    isPanning = false;
                    canvas.classList.remove('panning');
                }
                
                if (isSelecting && selectionBox) {
                    isSelecting = false;
                    selectionBox.remove();
                    selectionBox = null;
                }
            });
        }

        function updateViewportTransform() {
            const viewport = document.getElementById('graphViewport');
            viewport.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
            
            // Update background grid to align with zoom and pan
            const canvas = document.getElementById('graphCanvas');
            const scaledGrid = gridSize * zoom;
            canvas.style.backgroundSize = `${scaledGrid}px ${scaledGrid}px`;
            canvas.style.backgroundPosition = `${panX % scaledGrid}px ${panY % scaledGrid}px`;
        }

        function zoomIn() {
            zoom = Math.min(3, zoom * 1.2);
            updateViewportTransform();
        }

        function zoomOut() {
            zoom = Math.max(0.1, zoom / 1.2);
            updateViewportTransform();
        }

        function resetView() {
            panX = 0;
            panY = 0;
            zoom = 1;
            updateViewportTransform();
        }

        function updateSelectionFromBox(boxLeft, boxTop, boxWidth, boxHeight) {
            const viewport = document.getElementById('graphViewport');
            const canvasRect = document.getElementById('graphCanvas').getBoundingClientRect();
            
            nodes.forEach(node => {
                const nodeEl = document.querySelector(`[data-node-id="${node.id}"]`);
                if (!nodeEl) return;
                
                const nodeRect = nodeEl.getBoundingClientRect();
                const nodeLeft = nodeRect.left - canvasRect.left;
                const nodeTop = nodeRect.top - canvasRect.top;
                const nodeRight = nodeLeft + nodeRect.width;
                const nodeBottom = nodeTop + nodeRect.height;
                
                const boxRight = boxLeft + boxWidth;
                const boxBottom = boxTop + boxHeight;
                
                // Check if node intersects with selection box
                const intersects = !(nodeRight < boxLeft || 
                                    nodeLeft > boxRight || 
                                    nodeBottom < boxTop || 
                                    nodeTop > boxBottom);
                
                if (intersects) {
                    selectedNodes.add(node.id);
                } else if (!selectedNodes.has(node.id)) {
                    // Don't remove from set during selection - only add
                }
            });
            
            renderGraph();
        }

        // Panel resize functionality
        function initializeResize() {
            const container = document.querySelector('.container');
            const leftHandle = document.getElementById('leftHandle');
            const rightHandle = document.getElementById('rightHandle');

            leftHandle.addEventListener('mousedown', (e) => {
                isResizingLeft = true;
                e.preventDefault();
            });

            rightHandle.addEventListener('mousedown', (e) => {
                isResizingRight = true;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (isResizingLeft) {
                    leftPanelWidth = Math.max(200, Math.min(500, e.clientX));
                    updatePanelSizes();
                } else if (isResizingRight) {
                    rightPanelWidth = Math.max(300, Math.min(600, window.innerWidth - e.clientX));
                    updatePanelSizes();
                }
            });

            document.addEventListener('mouseup', () => {
                isResizingLeft = false;
                isResizingRight = false;
            });
        }

        function updatePanelSizes() {
            const container = document.querySelector('.container');
            container.style.gridTemplateColumns = `${leftPanelWidth}px 1fr ${rightPanelWidth}px`;
            
            document.getElementById('leftHandle').style.left = `${leftPanelWidth}px`;
            document.getElementById('rightHandle').style.right = `${rightPanelWidth}px`;
            
            resizePreview();
        }
    </script>
</body>
</html>
